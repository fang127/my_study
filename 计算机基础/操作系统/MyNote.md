# 第一章 操作系统概述

## 一、操作系统的概念和功能
![alt text](/操作系统/picture/{3FD895C6-4966-4921-8B02-EE938D9C70FC}.png)
### 1.概念
定义：指*控制和管理整个计算机系统的硬件和软件资源*，并合理地组织调度计算机的工作的资源的分配；以*提供给用户和其他软件方便的接口和环境*；它是计算机系统中最基本的软件系统。

### 2.功能和目标
1. 操作系统是系统资源的管理者
![alt text](/操作系统/picture/{7D800743-E8E3-4362-8E2D-B907EF0FB15B}.png)
2. 向上提供方便易用的服务（封装思想，硬件只能听懂二进制语言，操作系统把硬件功能封装成简单易用的服务，使用户可以方便的使用计算机，用户无需知道运行的原理便可使用）
>   - 提供gui图形化用户接口方便用户使用
>   - 早期只能通过命令接口操作计算机（a.联机命令接口 = 交互式命令接口 b.脱机命令接口 = 批处理命令接口（将一系列命令记录在记事本中*.bat文件，有计算机一次执行））
>   - 程序接口：可以在程序中进行系统调用（广义指令）来使用程序接口。普通用户不可直接使用程序接口，只能通过程序代码间接使用。
![alt text](/操作系统/picture/{325B408B-1C76-4325-AA27-AC1D245998D0}.png)
3. 操作系统是最接近硬件的层次
>   - 实现对硬件机器的拓展：将CPU，内存，磁盘，显示器，键盘等硬件合理的组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。
### 3.总结
![alt text](/操作系统/picture/{5FC7C9B0-1B4F-4148-8731-79B9ECF1F8BE}.png)

## 二、操作系统的特征
![alt text](/操作系统/picture/{0B6888FB-416A-40B0-84AA-ECAA417FAC29}.png)

### 1.并发
指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。注意不要和并行概念混合：并行指两个或多个事件在同一时刻同时发生。
![alt text](/操作系统/picture/{B266435D-A468-4655-A296-7BC505489278}.png)
操作系统的并发性：指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。
>操作系统就是伴随着“多道程序技术”而出现的。因此，*操作系统和程序并发是一起诞生的*。
**注意**：
>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行
>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行
### 2.共享
指资源共享，系统中的资源可供内存中多个并发执行的进程共同使用。

两种共享方式：
1. 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。
2. 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。
>所谓的"同时"往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问地（即**分时共享**）。但是也可能是真地同时，比如扬声器同时播放qq音乐和b站视频，即微观上计算机也同时访问扬声器这个资源。
**并发和共享地关系**
![alt text](/操作系统/picture/{CAC8704B-BA40-4C24-B9E0-F767A3ACC360}.png)
### 3.虚拟
指把一个物理上的实体变为若干个逻辑上地对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。
![alt text](/操作系统/picture/{C3D51A3B-176E-4F7D-8B0A-369D48091AFE}.png)
![alt text](/操作系统/picture/{A60D070F-5F6C-405E-93F9-BF6EA8306F5D}.png)
虚拟技术：
1. 空分复用技术
2. 时分复用技术
> 显然，如果失去了并发性，则一个时间段内系统中只需允许一道程序，那么就失去了实现虚拟性地意义了，因此，没有并发性就谈不上虚拟性。
### 4.异步
指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程地执行不是一贯到底地，而是走走停停，以不可预知地速度向前推进，这就是进程地异步性。
![alt text](/操作系统/picture/{85DE4E66-7722-432D-A04A-6D39A625DEC4}.png)
### 5.总结
![alt text](/操作系统/picture/{4BD9D663-F635-4E72-9D59-097FF4B3F517}.png)

## 三、操作系统的发展和分类
1. 手工操作阶段
    - 在纸带机写代码，将纸带装进计算机，计算机读取纸带机执行操作。
    ![alt text](/操作系统/picture/{54D0B314-356A-42B7-9C40-BF2AA59E55D3}.png)
1. 单道批处理系统
    - 引入脱机输入、输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出。并由监督程序（操作系统的雏形）负责控制作业的输入和输出。
    ![alt text](/操作系统/picture/{06FD83F4-2CDC-4BFB-A3A1-123AAD77FB73}.png)
1. 多道批处理系统
    - 操作系统正式诞生
    ![alt text](/操作系统/picture/{E3664D9F-BE0F-4FFE-A852-38363C80E5B9}.png)
4. 分时操作系统
    - 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。
    ![alt text](/操作系统/picture/{2760ED74-D46B-40B7-AA65-42D5CA2CF2B9}.png)
5. 实时操作系统
    ![alt text](/操作系统/picture/{E6462F24-9270-44B8-8CC0-C873A7DE36C0}.png)
6. 其他操作系统
    ![alt text](/操作系统/picture/{B4FAC203-EC49-4E13-A2A8-D6290E1B8409}.png)
    
### 总结
![alt text](/操作系统/picture/{53D7FEB1-22B9-4B80-98C9-72D74FC69E61}.png)

## 四、操作系统的运行机制
![alt text](/操作系统/picture/{82FD7C1F-444E-483B-B688-94E5E0BAD518}.png)
### 1.指令
定义：就是处理器CPU能识别、执行的最基本命令。
### 2.内核程序vs.应用程序
普通程序员写的程序是应用程序，比如qq，微信等  
微软、苹果等实现的操作系统，是内核程序，由很多内核程序组成了“操作系统内核”，称为“内核（kernel）”。内核时操作系统最重要和核心的部分，也是最接近硬件的部分。  
甚至可以说，一个操作系统只要有内核就足够了（eg：Docker仅需linux内核）。但操作系统的功能未必都在内核中，如图形化用户界面GUI。
### 3.特权指令vs.非特权指令
操作系统内核作为管理者，有时会让CPU执行一些特权指令，如内存清零指令。这些指令影响重大，只允许管理者即操作系统内核来使用。应用程序只能使用非特权指令，如加法指令、减法指令等。  
在CPU设计和生产大的时候就划分了特权指令和非特权指令，因此CPU执行一条命令前就能判断出其类型。
### 4.内核态vs.用户态
![alt text](/操作系统/picture/{6270BCF5-6FC0-44A1-A1EB-CA1C251D2470}.png)
**内核态、用户态的切换**
![alt text](/操作系统/picture/{405DB7EC-60B9-4EEF-A165-0A75C9E56FB6}.png)
### 5.总结
![alt text](/操作系统/picture/{608B88BF-E362-40BD-872F-6619EB228866}.png)

## 五、中断和异常
![alt text](/操作系统/picture/{D0D07B0A-0E95-4969-BC6C-36A506F77D08}.png)
### 1.中断的作用
![alt text](/操作系统/picture/{5956467C-851B-49EC-B38F-271BB2F8AD0D}.png)
### 2.中断的类型
1. 内中断
   > **与当前执行的指令有关，中断信号来源于CPU内部**
   - 例如：
   - 1. 试图在用户态下执行特权指令：当应用程序中有一条特权指令，则会发出中断信号，因此CPU处理中断信号，转为内核态
   - 2. 若当前执行的指令是非法的，则会引发一个中断信号：执行除法发现除数为0
   - 3. 有时应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令--陷入指令（非特权指令），该指令会引发一个内部中断信号。陷入指令的执行意味着应用程序主动地将CPU控制权还给操作系统内核，系统调用就是通过陷入指令完成地。
    >系统调用是指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。它提供了用户程序与操作系统之间的接口，使用户程序能够访问和使用操作系统的核心功能。
2. 外中断
   > **与当前执行的指令无关，中断信号来源于CPU外部**
    - 例如：
    - 1. 时钟中断：由时钟部件发来地中断信号
    > 时钟部件：每隔一个时间（如50ms）会给CPU发送一个时钟中断信号
    - 2. I/O中断：由输入/输出设备发来地中断信号
    > 当输入输出任务完成时，会向CPU发送中断信号  

    *CPU在每一条指令执行结束时，都会例行检查是否有外中断信号*
### 3.中断地分类
![alt text](/操作系统/picture/{DFF6C5EC-48E1-4DE5-9E79-89C117561AC5}.png)
### 4.中断机制的基本原理
![alt text](/操作系统/picture/{FF47353D-C9D1-453A-B98A-C39305E23B33}.png)
### 5.总结
![alt text](/操作系统/picture/{72428D93-E16D-4C2F-BA65-A975E0FF5FAA}.png)

## 六、系统调用
定义：系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。
### 1.系统调用和库函数的区别
![alt text](/操作系统/picture/{BCDBB7BC-4056-4F93-BDF8-A16FC24162BB}.png)
### 2.为什么系统调用是必须的
![alt text](/操作系统/picture/{A5469CA8-102D-4CB1-8D8C-CB4C56C67B56}.png)
![alt text](/操作系统/picture/{B6880107-8E10-4BD7-9E3E-E5C15B5F94C7}.png)
### 3.系统调用的过程
**系统调用的工作原理**
> 系统调用的工作原理涉及用户态和内核态的切换。操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互操>作需要在内核态执行，如设备I/O操作或进程间通信。
> 
> 当用户程序需要访问系统核心功能时，会通过系统调用接口使用系统调用。系统调用的过程如下：
> 
> 用户程序发出系统调用请求。
>
> 根据指令指明系统调用的类型以及参数，存储在寄存器中。
>
> 传递陷入指令
> 
> 操作系统接收到请求后，让处理器进入内核态。
>
> 根据寄存器中的参数判断用户需要哪种系统调用服务
> 
> 内核执行相应的操作，如I/O操作、进程管理等。
> 
> 操作完成后，处理器返回用户态，继续执行用户程序。

![alt text](/操作系统/picture/{FD33652B-7536-474C-808A-D0E4211EBB8B}.png)
### 4.总结
![alt text](/操作系统/picture/{D7B9E0F9-6811-4D7F-8876-4472E71F0F17}.png)

## 七、操作系统体系结构
![alt text](/操作系统/picture/{6C08D4F1-0E57-4424-98F3-04A1C8C61382}.png)
![alt text](/操作系统/picture/{4147FDCA-BF34-4F34-9B66-A63124A018D4}.png)
![alt text](/操作系统/picture/{15B5BBCB-C620-4E2A-B8A8-36CB8C075079}.png)
大内核和微内核会对系统性能有影响。
![alt text](/操作系统/picture/{16E5A37A-23F7-4CCC-AB49-F8083EE40DC0}.png)
### 大内核（又名：宏内核/单内核）
    - 将操作系统的主要功能模块都作为系统内核，运行在核心态
    - 优点：高性能
    - 缺点：内核代码庞大，结构混乱，难以维护
    - 典型的操作系统：linux，UNIX
### 微内核
    - 只把最基本的功能保留在内核
    - 优点：内核功能少，结构清晰，方便维护
    - 缺点：需要频繁的在核心态和用户态之间切换，性能低
    - 典型的操作系统：windows NT
### 分层结构
内核分多层，每层可单向调用更低一层提供的接口。  
> 最底层为硬件，最高层是用户接口。
- 优点：
  1. 便于调试和验证，自底向上逐层调试验证
  2. 易于扩充和维护，各层之间调用接口清晰固定
- 缺点：
  1. 仅可调用相邻底层，难以合理定义各层的边界（例如进程管理需调用内存管理，内存管理也要调用进程管理，对分层结构的设计造成了困难）
  2. 效率低，不可跨层调用，系统调用执行时间长
### 模块化
将内核划为多个模块，各模块之间相互协作。  
内核 = 主模块 + 可加载内核模块  
主模块：只负责核心功能，如进程调度，内存管理  
可加载内核模块：可以动态加载模块到内核，而无需重新编译整个内核。（例如一些驱动程序，外置设备的驱动程序）
![alt text](/操作系统/picture/{BDDFB041-B556-42B4-A7BC-8B2519B1A0F3}.png)
### 外核
内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。

内核分配的内存空间是经过抽象的连续空间，本质是离散的物理内存，是被连续内存空间映射的，由于本质是离散的内存，所以访问时磁头移动的频繁，移动距离大，不利于频繁的随机访问。而外核直接分配连续物理内存空间，不需要经过抽象化为连续空间，便于频繁的随机访问内存空间。

### 总结
![alt text](/操作系统/picture/{610194E9-F459-4E6D-BEB1-B28099DC81B0}.png)

## 八、操作系统的引导
定义：开机的时候，怎么让操作系统运行起来。  
磁盘按照操作系统后，磁盘开头部分有一个主引导记录（MBR）（包含磁盘引导程序和分区表）。   
分区表是一个数据结构，说明每个磁盘占有多大空间以及每个分区地址范围。
![alt text](/操作系统/picture/{066BDB54-98EF-4C21-93F4-7BE2D087F300}.png)  
c盘安装操作系统，是这个磁盘的活动分区，c盘进一步细分为：引导记录PBR（负责找到启动管理器），根目录，其他。
![alt text](/操作系统/picture/{7D8503BB-9F86-421E-81CB-DDDE91066C9B}.png)
RAM指运行内存，只要关机和断电，数据就被清除。
ROM（BIOS，基本输入\输出系统）包含ROM引导程序，即自举程序。关机与断电不会清除。只要开机通电，CPU就去ROM找ROM引导程序，从而执行指令，将磁盘的主引导记录读入RAM主存中，接着读去磁盘引导程序MBR，接着根据分区表判断c盘位置，进而读取分区引导记录PBR，从根目录找到启动管理器程序，从而完成操作系统初始化。
![alt text](/操作系统/picture/{530F5784-242D-4B47-A72C-96B2D05EF9FD}.png)
windows操作系统完整的初始化程序在 “根目录/windows/Boot”下。

## 九、虚拟机
传统计算机一台物理机器只能运行一个操作系统。但是一个操作系统可以同时运行多个进程，多个进程可能对操作系统的资源有争夺，会有安全隐患，因此发明了虚拟机，将一台物理机器虚拟化为多态虚拟机器，每个虚拟机器都可以独立运行一个操作系统。
![alt text](/操作系统/picture/{24ABDC2E-EA21-465D-94D6-4E3FB2A79749}.png)
### 两类虚拟机管理程序的对比
![alt text](/操作系统/picture/{20EF57F3-4858-4695-B8DC-2727342CA64C}.png)
第一类直接分配在硬件上，是连续的外存，性能更好，而第二类是经过宿主操作系统分配的虚拟内存，是通过多层映射的离散外存，性能差。

# 第二章 进程管理

## 一、进程的概念、组成、特征
### 1.进程和程序的概念
程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。
进程：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。
### 2.进程的组成
1. PCB
当进程被创建时，操作系统会为该进程分配一个*唯一的、不重复的“身份证”--PID（Process ID，进程ID）以及进程所属用户ID（UID）*，可以让操作系统区分各个进程。很多操作系统分配PID都是每个加1的策略。  
同时操作系统还会记录进程其它的使用信息，例如CPU占用，磁盘访问数据大小，可用于实现操作系统对进程的管理和调度。  
这些信息都被保存在一个数据结构PCB（Process Control Block）中，即*进程控制块*。    
操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息都会被放在PCB中。
![alt text](/操作系统/picture/{6D77C973-E5CA-4A78-9B29-2D0189DF1149}.png)
2. 程序段、数据段
![alt text](/操作系统/picture/{F15E0F90-356C-49F5-99C2-78F9AD991637}.png)
同时挂3个QQ，会对应3个qq进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的。
### 3.程序如何运行
![alt text](/操作系统/picture/{9FF63579-ECDB-46DC-B53D-44E79061F358}.png)
### 4.进程的特征
![alt text](/操作系统/picture/{BD6097F2-8706-40B8-BFA6-925D9721EE1B}.png)
### 5.总结
![alt text](/操作系统/picture/{736B99B7-FC88-4450-8BF5-B7D48A4A606A}.png)

## 二、进程的状态与转换
### 1.进程的状态--创建态、就绪态、运行态、阻塞态、终止态
![alt text](/操作系统/picture/{D4A0F133-58E8-44E2-A4EF-7B95657728AF}.png)
![alt text](/操作系统/picture/{3ADFCFC5-7EA0-4E21-B96F-A7F29F5D8E3C}.png)
![alt text](/操作系统/picture/{C578C584-6F13-4D94-B7CC-D9DB70C88E07}.png)
当一个进程可以执行exit系统调用，请求操作系统终止该进程，此时进程进入*终止态*，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，该进程就彻底消失了。
![alt text](/操作系统/picture/{38332A93-8B04-4653-83B7-B2512E0A1C9E}.png)
### 2.进程状态的转换
![alt text](/操作系统/picture/{AA703043-860C-4550-A6CB-3F69551931E2}.png)
### 3.进程的组织--链接方式
![alt text](/操作系统/picture/{D6F3EA8A-5CB5-49C9-B5A4-43C9D645A096}.png)
![alt text](/操作系统/picture/{AB434788-1A1F-42F6-BF46-7CD2F8E29A29}.png)
### 4.总结
![alt text](/操作系统/picture/{A7C139ED-C7A7-4F94-8751-46852FB5A9AD}.png)

## 三、进程控制
进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。即进程控制就是要实现进程状态转换。
![alt text](/操作系统/picture/{C1DCF31E-E4C8-4B3C-AE37-5256AB7A26E3}.png)
![alt text](/操作系统/picture/{D74DE2D8-CDEF-446A-B038-A83D587BFEAC}.png)
### 进程控制相关原语
1. 创建原语
   ![alt text](/操作系统/picture/{EE82697C-37FE-4E67-9E93-D9F6676314DD}.png)
2. 撤销原语
   ![alt text](/操作系统/picture/{77AA3908-DD60-45B3-B602-647E28E36A63}.png)
3. 阻塞原语和唤醒原语
   ![alt text](/操作系统/picture/{6383EA90-1D2E-4BC9-A5EF-366EF8714E83}.png)
4. 切换原语
   ![alt text](/操作系统/picture/{497F74A4-631F-4FF9-8DE5-F6F3AF34E7AF}.png)

> CPU中会设置很多**寄存器**，用来存放程序运行过程中的某些数据。
> PSW：程序状态字寄存器
> PC：程序计数器，存放下一条指令地址
> IR：指令寄存器，存放当前正在执行的指令
> 同用寄存器：其他一些必要信息
> 等等...
   ![alt text](/操作系统/picture/{E1FDD679-3741-47BA-89CA-ADB4099EB6C6}.png)
   当一个进程下CPU时，会被另一个进程覆盖寄存器信息，因此需要*在PCB中保存这个进程的运行环境*（保存一些必要的寄存器信息），存入PCB中。当原进程再次投入运行时，可以通过PCB恢复它的运行环境。
### 总结
![alt text](/操作系统/picture/{6C468C77-D002-4290-8EDE-2520E700292C}.png)

## 四、进程通信
进程间通信（Inter-Process Communication,IPC）是指两个进程之间产生数据交互。
> 进程通信需要操作系统支持 -- 为什么？？？
> 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。各进程只能访问自己的内存地址空间，而无法访问其他进程的内存地址空间。
![alt text](/操作系统/picture/{806F845D-6354-47C2-AE04-A5517032D551}.png)
### 1.共享存储
通过内存中的共享存储区实现共享存储。
![alt text](/操作系统/picture/{C2DF432B-D8E9-4C04-BD5C-7853A03B8D1E}.png)
> 访问应该是互斥的，即一个进程访问共享存储区时，其他进程不可访问，每次只可一个进程访问共享存储区，这样避免同时进行错误（例如同时对共享存储区的某块地址进行写操作，会造成数据覆盖、丢失）。
1. 基础存储区的共享
    操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。
2. 基础数据结构的共享
    例如共享空间只能方一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
### 2.消息传递
![alt text](/操作系统/picture/{D1E88D5D-6055-4F75-BEF0-06B7C7A4C618}.png)
1. 直接通信方式
    ![alt text](/操作系统/picture/{9CFFB8C3-6FF9-4C6A-9B2B-D9C011982841}.png)
2. 间接通信方式
    ![alt text](/操作系统/picture/{562E3BB7-40BA-43C5-9D3F-2927906F9244}.png)
### 3.管道通信
![alt text](/操作系统/picture/{AE1A33B3-8155-4118-AA93-440B81AE037C}.png)
和共享存储类似，都是在内存中开辟一个大小固定的内存空间，但是共享存储大的方式只管分配内存空间，不管数据存储的方式和类型，而管道通信时队列，类似queue，先进先出，一段时间内只可单向。  
> 写进程往管道写数据，即便管道没被写满，*只要管道没空，读进程就可以从管道读数据*
> 读进程从管道读数据，即便管道没被读空，*只要管道没满，写进程就可以往管道写数据*
### 4.总结
![alt text](/操作系统/picture/{6CB95E67-EF2E-45D2-A285-71999147B75A}.png)

## 五、信号
![alt text](/操作系统/picture/{A72BEB66-970D-4898-ABDF-48E625D48B1F}.png)
### 1.信号的作用
信号：用于*通知进程某个特定事件已经发生*。进程收到一个信号后，对该信号进行处理。
![alt text](/操作系统/picture/{7A0C0AAF-7888-441C-8560-B523CB48F43B}.png)
### 2.信号实现原理
1. 信号的发送与保存
    ![alt text](/操作系统/picture/{5FA6A2AF-B299-44E9-A99F-BADADDFF9ED1}.png)
2. 信号的处理
    - 当进程从内核态转为用户态时（例如：系统调用返回、或中断处理返回时），例行检查是否有待处理的信号，如果有，就处理信号。
    ![alt text](/操作系统/picture/{A04D0EE8-3F3B-437D-A3B8-125FB74286F4}.png)
    ![alt text](/操作系统/picture/{6BB67436-6603-4E50-9707-D29348D7688E}.png)
    > 每个进程都可以有自己的自定义信号处理程序，如果没有，则按操作系统规定的默认处理程序。
    > 每个进程的blocked阻塞信号，也由各进程进行系统调用各自设置。
### 3.信号与异常的关系
![alt text](/操作系统/picture/{D197A609-C1AB-4D8B-8523-73993D92F9B1}.png)
### 4.总结
![alt text](/操作系统/picture/{C9B795C1-3A38-4F75-A6CE-24C6B0BBF10B}.png)

## 六、线程的概念和特点
### 1.什么是线程，为什么要引入线程
有的进程可能选哟同时做很多事情，而传统的进程只可串行地执行一系列程序。为此，引入了线程，来增加并发度。  
传统地进程是程序执行流地最小单位。  
引入线程后，C程序执行流的最小单位就不是进程了，而是线程，一个进程可以包含多个线程。
> 可以把线程理解为“轻量级进程”。
![alt text](/操作系统/picture/{48C1D1EA-F5EB-47A1-AB84-EE25A7456744}.png)
> 线程是一个基本的CPU执行单元，也是程序执行流的最小单位。
> 引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提高了系统的并发度，使得一个进程内也可以并发的处理各种任务（如QQ视频、文字聊天、传输文件等）。
> 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。
![alt text](/操作系统/picture/{E869CF0B-E1ED-4238-9F38-CA66FC547A9F}.png)
### 2.线程的属性
![alt text](/操作系统/picture/{B445C217-E079-4EFB-946B-D40DCE45421A}.png)

## 七、线程的实现方式和多线程模型
![alt text](/操作系统/picture/{0BBE106A-B142-4980-AE45-83596DF9B9C1}.png)
### 1.用户级线程（User-Level Thread,ULT）
![alt text](/操作系统/picture/{8C4FA0E9-32C3-4DD8-BC5F-6C46D4B35245}.png)
![alt text](/操作系统/picture/{DC28DE03-78F8-4E9C-8FA9-4124EDB5D9F0}.png)
### 2.内核级线程（Kernel-Level Thread,KLT,又称“内核支持的线程”）
![alt text](/操作系统/picture/{C833FD45-FC2C-463C-8E03-7D5F04247B8A}.png)
### 3.多线程模型
1. 一对一模型
![alt text](/操作系统/picture/{76B24742-1716-4ED4-AF31-64622AB96EA4}.png)
2. 多对一模型
![alt text](/操作系统/picture/{B29EA9C1-4455-4E74-91E3-1870FDE44E30}.png)
3. 多对多模型
![alt text](/操作系统/picture/{4CBB4235-7780-4A3C-A411-EEE139520068}.png)
### 4.总结
![alt text](/操作系统/picture/{52DC8310-310D-4554-8A1C-BCB1B1EEB4F4}.png)

## 八、线程的状态与转换、组织与控制
![alt text](/操作系统/picture/{65901616-32D2-4D00-993D-286A0A50CD11}.png)
![alt text](/操作系统/picture/{32BD3336-6E3B-42A0-AD97-2C64D18A2723}.png)
> 线程这两个部分和进程类似

## 九、处理机调度概念、层次
### 1.调度的基本概念
当有一堆任务要处理时，但由于资源有限，这些事情没办法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。
### 2.调度的三个层次
1. 高级调度（作业调度）
    - 作业：一个具体的任务
    - 用户向系统提交了一个作业 = 用户让操作系统启动一个程序（来处理一个具体的任务）。
    > 高级调度。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。
2. 低级调度
    > 低级调度（进程调度/处理机调度）--按照某种策略从就绪队列中选取一个进程，将处理机分配给它。
    ![alt text](/操作系统/picture/{0856861B-C947-45E9-B117-C4E0B8B6BB1A}.png)
    - 低级调度的频率很高，一般几十毫秒一次，所以宏观上看是同时运行，即满足操作系统并发的特性。
3. 中级调度
    ![alt text](/操作系统/picture/{FE970BBB-5ACB-4CBC-B101-5B91E82C129A}.png)
### 3.进程的挂起态与七状态模型
![alt text](/操作系统/picture/{1DB8A966-C7D9-47DB-8A40-FDCB32C40DC2}.png)
### 4.三层调度的联系、对比
![alt text](/操作系统/picture/{0715AD4A-FDF1-4191-88A9-A04EABED6DB5}.png)
### 5.总结
![alt text](/操作系统/picture/{95FE35C8-864F-4A61-839C-5D894D4C8688}.png)

## 十、进程调度的时机切换与过程调度方式
### 1.进程调度的时机
![alt text](/操作系统/picture/{07D2C07A-0636-4B7C-A7EB-29FE33650AA9}.png)
![alt text](/操作系统/picture/{FB4BBF5E-9128-47C4-A6E1-433E88656ECD}.png)
> 普通临界区访问的临界资源不会影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。
### 2.进程调度的方式
![alt text](/操作系统/picture/{0EFB9304-3216-4260-BDB4-00C326906DEA}.png)
### 3.进程的切换与过程
![alt text](/操作系统/picture/{7C21B275-FD5E-455B-95F0-3799AFBCFBFF}.png)
### 4.总结
![alt text](/操作系统/picture/{509A102E-A3DF-4713-96C6-7824411D11D4}.png)

## 十一、调度器/调度程序
![alt text](/操作系统/picture/{0A786E8C-D7AA-4CFE-B1FA-6B603ADC03E8}.png)
> 不支持内核级线程的操作系统，调度程序处理的对象时进程
> 支持内核级线程的操作系统，调度程序的处理对象我是内核线程

![alt text](/操作系统/picture/{5812B6AE-DCFB-4479-ACC2-3BB3A7B5EC18}.png)

## 十二、调度算法的评价指标
### 1.CPU利用率
![alt text](/操作系统/picture/{DBA6E7AB-6327-422F-AEEA-3E29D27B3BB2}.png)
### 2.系统吞吐量
![alt text](/操作系统/picture/{0807BEC0-B425-49F4-A8A7-DA52B223D5C9}.png)
### 3.周转时间
![alt text](/操作系统/picture/{F0A4B6B2-6BC1-400D-81B2-47E8A3F1520C}.png)
### 4.带权周转时间
![alt text](/操作系统/picture/{13FEB959-8F32-45A1-9D40-658AD59A5846}.png)
### 5.等待时间
![alt text](/操作系统/picture/{2D35789B-5E5F-47BC-AE72-BFEFC7358F7F}.png)
### 6.响应时间
响应时间指从用户提交请求到首次产生响应所用的时间
### 7.总结
![alt text](/操作系统/picture/{D4F69B51-E08B-41EE-9AF1-41805C1ADDDE}.png)

## 十三、调度算法（上）
### 算法思想
1. 先来先服务（FCFS，First Come First Serve）
![alt text](/操作系统/picture/{98C22562-FB3B-4FDF-AD4A-31513CF409FE}.png)
> 可以看见P3的带权周转时间很大，为8，所以体验很差
- 总结
![alt text](/操作系统/picture/{D133FE05-6858-4539-A968-C0BC7FCC7291}.png)
2. 短作业优先（SJF，Shortest Job First）
- 非抢占式
![alt text](/操作系统/picture/{B9336E03-B615-4741-9557-BF18DC4EF1CF}.png)
- 抢占式
![alt text](/操作系统/picture/{9597D6DB-0A6A-4E78-9D39-30D3CA6F881F}.png)
- 注意  
![alt text](/操作系统/picture/{076DA7CD-9C3B-4BDE-940D-B8FB3AFD1B5D}.png)
- 总结
![alt text](/操作系统/picture/{B31FF026-CA96-4A9C-9E2C-56630B8D0E40}.png)
3. 对FCFS和SJF两种算法的思考
![alt text](/操作系统/picture/{20FACC2D-D0AC-44BE-A8DB-AF7118F14C8A}.png)
4. 高响应比优先（HRRN,Hightest Response Ratio Next）
![alt text](/操作系统/picture/{F621F7A9-929C-4647-ABBA-35BB0904349B}.png)
- 总结
![alt text](/操作系统/picture/{7A6ABE32-34A3-4788-BA7E-B486227FEB85}.png)
### 总结
![alt text](/操作系统/picture/{6BCA20CC-C8F5-40F0-9F89-AC9E69AEB654}.png)

## 十四、调度算法（下）
### 算法思想
1. 时间片轮转（RR，Round-Robin）
![alt text](/操作系统/picture/{51BEDA8C-28DA-4272-9BA1-2773A1ADD5A2}.png)
![alt text](/操作系统/picture/{190524AA-8644-4E29-960B-3A0300E568F0}.png)
- 总结
![alt text](/操作系统/picture/{A10EEF74-A670-4BDD-964E-A004E2032340}.png)
2. 优先级调度算法
- 非抢占式
![alt text](/操作系统/picture/{C8F6EC3C-251E-447F-BF92-3388A2FB2E84}.png)
- 抢占式
![alt text](/操作系统/picture/{D529C978-ED4A-411F-A88C-82DF382F19CD}.png)
- 补充
![alt text](/操作系统/picture/{16874959-4FD9-4932-9C6C-5B897B342CD3}.png)
- 总结
![alt text](/操作系统/picture/{F3E54D7A-33B1-45B2-9B99-3ED0AB428B29}.png)

> ![alt text](/操作系统/picture/{5C5C3480-206E-4581-8AD9-5C003D2A8E0B}.png)

3. 多级反馈队列调度算法
![alt text](/操作系统/picture/{ABDF3CE7-4BA2-4912-881D-EA6B1B419F59}.png)
- 总结
![alt text](/操作系统/picture/{89CC4402-0DFF-4ACE-B9D5-E513B211EDA1}.png)
### 总结
![alt text](/操作系统/picture/{88C69D1B-58C3-4170-A39E-CC6D31DA9834}.png)

## 十五、多级队列调度算法
![alt text](/操作系统/picture/{A2EDD2D5-EFF6-4492-B73C-DADE0C86B0E3}.png)

## 十六、多处理机调度
### 多处理机调度相对单处理机调度面临的问题
![alt text](/操作系统/picture/{061DDA1A-FE0B-4EA7-805D-1F3448B4CCD6}.png)
![alt text](/操作系统/picture/{2DD721F3-37A3-4A85-B6AA-4676CC15DC6D}.png)
### 解决
1. 公共就绪队列
![alt text](/操作系统/picture/{1D04BA84-2475-4391-A41E-AB66CA674205}.png)
2. 私有就绪队列
![alt text](/操作系统/picture/{B66556E0-A6A9-48CC-B590-E9D8A9811CD3}.png)
![alt text](/操作系统/picture/{0DA35224-E953-4440-8464-995474956A31}.png)
> 私有就绪队列天然地实现了“处理机亲和性”，但是在处理负载均衡时，会牺牲一部分亲和性，这时，同样可以采用硬亲和地策略，有进程进行系统调用，保证进程地亲和性。
### 总结
![alt text](/操作系统/picture/{18EFB367-F9D0-4C71-A8E3-9E5A6558220F}.png)

## 十七、进程同步、互斥
知识点回顾：进程具有异步性地特征，即各并发执行的进程以各自独立的、不可预知的速度向前推进。
![alt text](/操作系统/picture/{3B369CBC-295B-45CD-900B-30261C6DD6A7}.png)

### 进程同步
![alt text](/操作系统/picture/{23817294-205B-4CEB-AD65-F46E5F322AE9}.png)
### 进程互斥
![alt text](/操作系统/picture/{4BED9824-9A4D-41D7-A34B-3C9BC61B4573}.png)
![alt text](/操作系统/picture/{49680E96-2871-443F-B191-D7871E05B5A0}.png)
![alt text](/操作系统/picture/{D7540A26-C39F-45D1-91A9-077FFC937FBC}.png)
### 总结
![alt text](/操作系统/picture/{656098A7-C3F4-4485-AE0D-D2E8CA1E33F8}.png)

## 十八、进程互斥的软件实现方法
没有进程互斥机制的后果：
![alt text](/操作系统/picture/{32C5881D-CC53-4325-978A-90D7B69F0027}.png)
### 1.单标志法
![alt text](/操作系统/picture/{FAAD3AEF-28A9-48E4-A05A-7EC4EAEEBE2F}.png)
> 缺点：违背“空闲让进”的原则。
### 2.双标志先检查法
![alt text](/操作系统/picture/{77EFDEEA-FD97-4544-A389-247D428C192D}.png)
> 缺点：违反“忙着等待”原则。
### 3.双标志后检查法
![alt text](/操作系统/picture/{6848FA0A-8B0A-4E31-841E-DFFE8974AC93}.png)
> 缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。
### 4.Peterson算法
![alt text](/操作系统/picture/{FBD28B02-8B9E-44DC-AA2E-E82B67A05DBB}.png)
> Peterson算法利用软件方法解决了进程互斥的问题，遵循了空闲让进，忙则等待、有限等待三个原则，但依然未遵守让权等待的原则。
### 5.总结
![alt text](/操作系统/picture/{992487B1-6921-4CE7-A7F7-DEAE46BD3C10}.png)

## 十九、进程互斥的硬件实现方法
### 1.中断屏蔽方法
![alt text](/操作系统/picture/{6222D1B6-63AE-4B40-8B1F-99ADB293E15A}.png)
### 2.TestAndSet方法
![alt text](/操作系统/picture/{EEC91189-2DF1-49F6-9F07-A02E379D1735}.png)
### 3.Swap指令
![alt text](/操作系统/picture/{524D109D-DD1E-483B-9506-F003FCCA8C19}.png)
### 4.总结
![alt text](/操作系统/picture/{FFCC68D4-57E8-48A3-A73E-6B0E3E8CACE3}.png)

## 二十、互斥锁
![alt text](/操作系统/picture/{7F07215A-879F-42A4-81E4-7EF954ED6432}.png)
![alt text](/操作系统/picture/{1BC3751D-4067-4D20-ADC9-74CB700FDD5C}.png)

## 二十一、信号量机制
![alt text](/操作系统/picture/{FF518637-96D3-4B9B-A272-4CC607E519F0}.png)
### 1.信号量机制定义
![alt text](/操作系统/picture/{9702377A-4E02-4291-BE55-5121792F10E2}.png)
1. 整型信号量
用一个整数表示系统资源的变量，用来表示系统中某种资源的数量
~~~c++
// eg：某计算机系统只要一台打印机
int S=1;
void wait(int &S){ //wait原语，相当于：进入区
  while(S<=0); //如果资源数不够，就一直循环等待
  S=S-1;    //如果资源数够，则占用一个资源
}
​
void signal(int &S){//signal原语，相当于“退出区”
  S=S+1;    //使用完资源后，在退出区释放资源
}

进程P0：
wait(S); // 进入区，申请资源
{}// 使用打印机资源代码
signal(S) // 退出区，释放资源

进程P1：
wait(S); // 进入区，申请资源
{}// 使用打印机资源代码
signal(S) // 退出区，释放资源

/*
   ......其余进程
*/

进程Pn：
wait(S); // 进入区，申请资源
{}// 使用打印机资源代码
signal(S) // 退出区，释放资源
~~~
> wait原语，“检查”和“上锁”一气呵成，避免并发、异步导致的问题
> 缺点：可能会出现盲等。
2. 记录型信号量
记录型数据结构表示的信号量
~~~c++
//记录型信号量的定义
typedef struct{
  int value;
  struct process *L;
} semaphore;
//某进程需要使用资源时，通过wait原语申请
void wait (semaphore S){
  S.value--;
  if(S.value<0){
    block (S.L);//将该进程加入到等待队列中，置为阻塞态
 }
}
//进程使用完资源后，通过signal原语释放
void signal (semaphore S){
  S.value++;
  if(S.value<=0){ //s.value为负数，说明有|value|个阻塞态的进程
    wakeup(S.L); // 唤醒等待队列中阻塞态进程
 }
}
~~~
> 除非特别说明，否则默认S为记录型信号量
> ![alt text](/操作系统/picture/{2B7C71F6-D77F-4FD2-9DEF-3B3E70193257}.png)

### 2.总结
![alt text](/操作系统/picture/{6A57FAFC-709D-4010-8848-24B1EF38BFFF}.png)

## 二十二、用信号量机制实现进程互斥、同步、前驱关系
![alt text](/操作系统/picture/{8B93164C-6033-4CB4-8193-3FDD3796FD8A}.png)
### 1.实现进程互斥
![alt text](/操作系统/picture/{CD25CC5F-D613-40DB-9B3A-7143B3D05605}.png)
### 2.实现进程同步
![alt text](/操作系统/picture/{F1ECD47D-EDD5-40A8-8330-B3E98C189E8F}.png)
### 3.实现前驱关系
![alt text](/操作系统/picture/{13C46257-916E-44F0-946B-E6A5C79B4545}.png)
### 4.总结
![alt text](/操作系统/picture/{00BA714B-6624-4BFA-897F-CB683D9EC42D}.png)

## 二十三、生产者消费者问题
### 问题描述
![alt text](/操作系统/picture/{F8229727-22A4-4F80-AC55-F7E6B982E9CB}.png)
### 问题实现
![alt text](/操作系统/picture/{32545A89-511B-4E65-AB9F-5C3D0F475CBD}.png)
### 思考
![alt text](/操作系统/picture/{435C2832-86C9-4F6B-9940-3ACC3780545D}.png)
> 要保证临界区代码简短，避免将生产产品和使用产品放入临界区，放入临界区会不利于各进程并发使用临界区资源，会对性能造成影响
### 总结
![alt text](/操作系统/picture/{0DC2F21F-2C5C-4CE6-A178-1793B1F190B7}.png)

## 二十四、多生产者、多消费者问题
