# 第一章 操作系统概述

## 一、操作系统的概念和功能
![alt text](/操作系统/picture/{3FD895C6-4966-4921-8B02-EE938D9C70FC}.png)
### 1.概念
定义：指*控制和管理整个计算机系统的硬件和软件资源*，并合理地组织调度计算机的工作的资源的分配；以*提供给用户和其他软件方便的接口和环境*；它是计算机系统中最基本的软件系统。

### 2.功能和目标
1. 操作系统是系统资源的管理者
![alt text](/操作系统/picture/{7D800743-E8E3-4362-8E2D-B907EF0FB15B}.png)
2. 向上提供方便易用的服务（封装思想，硬件只能听懂二进制语言，操作系统把硬件功能封装成简单易用的服务，使用户可以方便的使用计算机，用户无需知道运行的原理便可使用）
>   - 提供gui图形化用户接口方便用户使用
>   - 早期只能通过命令接口操作计算机（a.联机命令接口 = 交互式命令接口 b.脱机命令接口 = 批处理命令接口（将一系列命令记录在记事本中*.bat文件，有计算机一次执行））
>   - 程序接口：可以在程序中进行系统调用（广义指令）来使用程序接口。普通用户不可直接使用程序接口，只能通过程序代码间接使用。
![alt text](/操作系统/picture/{325B408B-1C76-4325-AA27-AC1D245998D0}.png)
3. 操作系统是最接近硬件的层次
>   - 实现对硬件机器的拓展：将CPU，内存，磁盘，显示器，键盘等硬件合理的组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。
### 3.总结
![alt text](/操作系统/picture/{5FC7C9B0-1B4F-4148-8731-79B9ECF1F8BE}.png)

## 二、操作系统的特征
![alt text](/操作系统/picture/{0B6888FB-416A-40B0-84AA-ECAA417FAC29}.png)

### 1.并发
指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。注意不要和并行概念混合：并行指两个或多个事件在同一时刻同时发生。
![alt text](/操作系统/picture/{B266435D-A468-4655-A296-7BC505489278}.png)
操作系统的并发性：指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。
>操作系统就是伴随着“多道程序技术”而出现的。因此，*操作系统和程序并发是一起诞生的*。
**注意**：
>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行
>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行
### 2.共享
指资源共享，系统中的资源可供内存中多个并发执行的进程共同使用。

两种共享方式：
1. 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。
2. 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。
>所谓的"同时"往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问地（即**分时共享**）。但是也可能是真地同时，比如扬声器同时播放qq音乐和b站视频，即微观上计算机也同时访问扬声器这个资源。
**并发和共享地关系**
![alt text](/操作系统/picture/{CAC8704B-BA40-4C24-B9E0-F767A3ACC360}.png)
### 3.虚拟
指把一个物理上的实体变为若干个逻辑上地对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。
![alt text](/操作系统/picture/{C3D51A3B-176E-4F7D-8B0A-369D48091AFE}.png)
![alt text](/操作系统/picture/{A60D070F-5F6C-405E-93F9-BF6EA8306F5D}.png)
虚拟技术：
1. 空分复用技术
2. 时分复用技术
> 显然，如果失去了并发性，则一个时间段内系统中只需允许一道程序，那么就失去了实现虚拟性地意义了，因此，没有并发性就谈不上虚拟性。
### 4.异步
指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程地执行不是一贯到底地，而是走走停停，以不可预知地速度向前推进，这就是进程地异步性。
![alt text](/操作系统/picture/{85DE4E66-7722-432D-A04A-6D39A625DEC4}.png)
### 5.总结
![alt text](/操作系统/picture/{4BD9D663-F635-4E72-9D59-097FF4B3F517}.png)

## 三、操作系统的发展和分类
1. 手工操作阶段
    - 在纸带机写代码，将纸带装进计算机，计算机读取纸带机执行操作。
    ![alt text](/操作系统/picture/{54D0B314-356A-42B7-9C40-BF2AA59E55D3}.png)
1. 单道批处理系统
    - 引入脱机输入、输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出。并由监督程序（操作系统的雏形）负责控制作业的输入和输出。
    ![alt text](/操作系统/picture/{06FD83F4-2CDC-4BFB-A3A1-123AAD77FB73}.png)
1. 多道批处理系统
    - 操作系统正式诞生
    ![alt text](/操作系统/picture/{E3664D9F-BE0F-4FFE-A852-38363C80E5B9}.png)
4. 分时操作系统
    - 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。
    ![alt text](/操作系统/picture/{2760ED74-D46B-40B7-AA65-42D5CA2CF2B9}.png)
5. 实时操作系统
    ![alt text](/操作系统/picture/{E6462F24-9270-44B8-8CC0-C873A7DE36C0}.png)
6. 其他操作系统
    ![alt text](/操作系统/picture/{B4FAC203-EC49-4E13-A2A8-D6290E1B8409}.png)
    
### 总结
![alt text](/操作系统/picture/{53D7FEB1-22B9-4B80-98C9-72D74FC69E61}.png)

## 四、操作系统的运行机制
![alt text](/操作系统/picture/{82FD7C1F-444E-483B-B688-94E5E0BAD518}.png)
### 1.指令
定义：就是处理器CPU能识别、执行的最基本命令。
### 2.内核程序vs.应用程序
普通程序员写的程序是应用程序，比如qq，微信等  
微软、苹果等实现的操作系统，是内核程序，由很多内核程序组成了“操作系统内核”，称为“内核（kernel）”。内核时操作系统最重要和核心的部分，也是最接近硬件的部分。  
甚至可以说，一个操作系统只要有内核就足够了（eg：Docker仅需linux内核）。但操作系统的功能未必都在内核中，如图形化用户界面GUI。
### 3.特权指令vs.非特权指令
操作系统内核作为管理者，有时会让CPU执行一些特权指令，如内存清零指令。这些指令影响重大，只允许管理者即操作系统内核来使用。应用程序只能使用非特权指令，如加法指令、减法指令等。  
在CPU设计和生产大的时候就划分了特权指令和非特权指令，因此CPU执行一条命令前就能判断出其类型。
### 4.内核态vs.用户态
![alt text](/操作系统/picture/{6270BCF5-6FC0-44A1-A1EB-CA1C251D2470}.png)
**内核态、用户态的切换**
![alt text](/操作系统/picture/{405DB7EC-60B9-4EEF-A165-0A75C9E56FB6}.png)
### 5.总结
![alt text](/操作系统/picture/{608B88BF-E362-40BD-872F-6619EB228866}.png)

## 五、中断和异常
![alt text](/操作系统/picture/{D0D07B0A-0E95-4969-BC6C-36A506F77D08}.png)
### 1.中断的作用
![alt text](/操作系统/picture/{5956467C-851B-49EC-B38F-271BB2F8AD0D}.png)
### 2.中断的类型
1. 内中断
   > **与当前执行的指令有关，中断信号来源于CPU内部**
   - 例如：
   - 1. 试图在用户态下执行特权指令：当应用程序中有一条特权指令，则会发出中断信号，因此CPU处理中断信号，转为内核态
   - 2. 若当前执行的指令是非法的，则会引发一个中断信号：执行除法发现除数为0
   - 3. 有时应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令--陷入指令（非特权指令），该指令会引发一个内部中断信号。陷入指令的执行意味着应用程序主动地将CPU控制权还给操作系统内核，系统调用就是通过陷入指令完成地。
    >系统调用是指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。它提供了用户程序与操作系统之间的接口，使用户程序能够访问和使用操作系统的核心功能。
2. 外中断
   > **与当前执行的指令无关，中断信号来源于CPU外部**
    - 例如：
    - 1. 时钟中断：由时钟部件发来地中断信号
    > 时钟部件：每隔一个时间（如50ms）会给CPU发送一个时钟中断信号
    - 2. I/O中断：由输入/输出设备发来地中断信号
    > 当输入输出任务完成时，会向CPU发送中断信号  

    *CPU在每一条指令执行结束时，都会例行检查是否有外中断信号*
### 3.中断地分类
![alt text](/操作系统/picture/{DFF6C5EC-48E1-4DE5-9E79-89C117561AC5}.png)
### 4.中断机制的基本原理
![alt text](/操作系统/picture/{FF47353D-C9D1-453A-B98A-C39305E23B33}.png)
### 5.总结
![alt text](/操作系统/picture/{72428D93-E16D-4C2F-BA65-A975E0FF5FAA}.png)

## 六、系统调用
定义：系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。
### 1.系统调用和库函数的区别
![alt text](/操作系统/picture/{BCDBB7BC-4056-4F93-BDF8-A16FC24162BB}.png)
### 2.为什么系统调用是必须的
![alt text](/操作系统/picture/{A5469CA8-102D-4CB1-8D8C-CB4C56C67B56}.png)
![alt text](/操作系统/picture/{B6880107-8E10-4BD7-9E3E-E5C15B5F94C7}.png)
### 3.系统调用的过程
**系统调用的工作原理**
> 系统调用的工作原理涉及用户态和内核态的切换。操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互操>作需要在内核态执行，如设备I/O操作或进程间通信。
> 
> 当用户程序需要访问系统核心功能时，会通过系统调用接口使用系统调用。系统调用的过程如下：
> 
> 用户程序发出系统调用请求。
>
> 根据指令指明系统调用的类型以及参数，存储在寄存器中。
>
> 传递陷入指令
> 
> 操作系统接收到请求后，让处理器进入内核态。
>
> 根据寄存器中的参数判断用户需要哪种系统调用服务
> 
> 内核执行相应的操作，如I/O操作、进程管理等。
> 
> 操作完成后，处理器返回用户态，继续执行用户程序。

![alt text](/操作系统/picture/{FD33652B-7536-474C-808A-D0E4211EBB8B}.png)
### 4.总结
![alt text](/操作系统/picture/{D7B9E0F9-6811-4D7F-8876-4472E71F0F17}.png)

## 七、操作系统体系结构
![alt text](/操作系统/picture/{6C08D4F1-0E57-4424-98F3-04A1C8C61382}.png)
![alt text](/操作系统/picture/{4147FDCA-BF34-4F34-9B66-A63124A018D4}.png)
![alt text](/操作系统/picture/{15B5BBCB-C620-4E2A-B8A8-36CB8C075079}.png)
大内核和微内核会对系统性能有影响。
![alt text](/操作系统/picture/{16E5A37A-23F7-4CCC-AB49-F8083EE40DC0}.png)
### 大内核（又名：宏内核/单内核）
    - 将操作系统的主要功能模块都作为系统内核，运行在核心态
    - 优点：高性能
    - 缺点：内核代码庞大，结构混乱，难以维护
    - 典型的操作系统：linux，UNIX
### 微内核
    - 只把最基本的功能保留在内核
    - 优点：内核功能少，结构清晰，方便维护
    - 缺点：需要频繁的在核心态和用户态之间切换，性能低
    - 典型的操作系统：windows NT
### 分层结构
内核分多层，每层可单向调用更低一层提供的接口。  
> 最底层为硬件，最高层是用户接口。
- 优点：
  1. 便于调试和验证，自底向上逐层调试验证
  2. 易于扩充和维护，各层之间调用接口清晰固定
- 缺点：
  1. 仅可调用相邻底层，难以合理定义各层的边界（例如进程管理需调用内存管理，内存管理也要调用进程管理，对分层结构的设计造成了困难）
  2. 效率低，不可跨层调用，系统调用执行时间长
### 模块化
将内核划为多个模块，各模块之间相互协作。  
内核 = 主模块 + 可加载内核模块  
主模块：只负责核心功能，如进程调度，内存管理  
可加载内核模块：可以动态加载模块到内核，而无需重新编译整个内核。（例如一些驱动程序，外置设备的驱动程序）
![alt text](/操作系统/picture/{BDDFB041-B556-42B4-A7BC-8B2519B1A0F3}.png)
### 外核
内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。

内核分配的内存空间是经过抽象的连续空间，本质是离散的物理内存，是被连续内存空间映射的，由于本质是离散的内存，所以访问时磁头移动的频繁，移动距离大，不利于频繁的随机访问。而外核直接分配连续物理内存空间，不需要经过抽象化为连续空间，便于频繁的随机访问内存空间。

### 总结
![alt text](/操作系统/picture/{610194E9-F459-4E6D-BEB1-B28099DC81B0}.png)

## 八、操作系统的引导
定义：开机的时候，怎么让操作系统运行起来。  
磁盘按照操作系统后，磁盘开头部分有一个主引导记录（MBR）（包含磁盘引导程序和分区表）。   
分区表是一个数据结构，说明每个磁盘占有多大空间以及每个分区地址范围。
![alt text](/操作系统/picture/{066BDB54-98EF-4C21-93F4-7BE2D087F300}.png)  
c盘安装操作系统，是这个磁盘的活动分区，c盘进一步细分为：引导记录PBR（负责找到启动管理器），根目录，其他。
![alt text](/操作系统/picture/{7D8503BB-9F86-421E-81CB-DDDE91066C9B}.png)
RAM指运行内存，只要关机和断电，数据就被清除。
ROM（BIOS，基本输入\输出系统）包含ROM引导程序，即自举程序。关机与断电不会清除。只要开机通电，CPU就去ROM找ROM引导程序，从而执行指令，将磁盘的主引导记录读入RAM主存中，接着读去磁盘引导程序MBR，接着根据分区表判断c盘位置，进而读取分区引导记录PBR，从根目录找到启动管理器程序，从而完成操作系统初始化。
![alt text](/操作系统/picture/{530F5784-242D-4B47-A72C-96B2D05EF9FD}.png)
windows操作系统完整的初始化程序在 “根目录/windows/Boot”下。

## 九、虚拟机
传统计算机一台物理机器只能运行一个操作系统。但是一个操作系统可以同时运行多个进程，多个进程可能对操作系统的资源有争夺，会有安全隐患，因此发明了虚拟机，将一台物理机器虚拟化为多态虚拟机器，每个虚拟机器都可以独立运行一个操作系统。
![alt text](/操作系统/picture/{24ABDC2E-EA21-465D-94D6-4E3FB2A79749}.png)
### 两类虚拟机管理程序的对比
![alt text](/操作系统/picture/{20EF57F3-4858-4695-B8DC-2727342CA64C}.png)
第一类直接分配在硬件上，是连续的外存，性能更好，而第二类是经过宿主操作系统分配的虚拟内存，是通过多层映射的离散外存，性能差。

# 第二章 进程管理

## 一、进程的概念、组成、特征
### 1.进程和程序的概念
程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。
进程：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。
### 2.进程的组成
1. PCB
当进程被创建时，操作系统会为该进程分配一个*唯一的、不重复的“身份证”--PID（Process ID，进程ID）以及进程所属用户ID（UID）*，可以让操作系统区分各个进程。很多操作系统分配PID都是每个加1的策略。  
同时操作系统还会记录进程其它的使用信息，例如CPU占用，磁盘访问数据大小，可用于实现操作系统对进程的管理和调度。  
这些信息都被保存在一个数据结构PCB（Process Control Block）中，即*进程控制块*。    
操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息都会被放在PCB中。
![alt text](/操作系统/picture/{6D77C973-E5CA-4A78-9B29-2D0189DF1149}.png)
2. 程序段、数据段
![alt text](/操作系统/picture/{F15E0F90-356C-49F5-99C2-78F9AD991637}.png)
同时挂3个QQ，会对应3个qq进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的。
### 3.程序如何运行
![alt text](/操作系统/picture/{9FF63579-ECDB-46DC-B53D-44E79061F358}.png)
### 4.进程的特征
![alt text](/操作系统/picture/{BD6097F2-8706-40B8-BFA6-925D9721EE1B}.png)
### 5.总结
![alt text](/操作系统/picture/{736B99B7-FC88-4450-8BF5-B7D48A4A606A}.png)

## 二、进程的状态与转换
### 1.进程的状态--创建态、就绪态、运行态、阻塞态、终止态
![alt text](/操作系统/picture/{D4A0F133-58E8-44E2-A4EF-7B95657728AF}.png)
![alt text](/操作系统/picture/{3ADFCFC5-7EA0-4E21-B96F-A7F29F5D8E3C}.png)
![alt text](/操作系统/picture/{C578C584-6F13-4D94-B7CC-D9DB70C88E07}.png)
当一个进程可以执行exit系统调用，请求操作系统终止该进程，此时进程进入*终止态*，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，该进程就彻底消失了。
![alt text](/操作系统/picture/{38332A93-8B04-4653-83B7-B2512E0A1C9E}.png)
### 2.进程状态的转换
![alt text](/操作系统/picture/{AA703043-860C-4550-A6CB-3F69551931E2}.png)
### 3.进程的组织--链接方式
![alt text](/操作系统/picture/{D6F3EA8A-5CB5-49C9-B5A4-43C9D645A096}.png)
![alt text](/操作系统/picture/{AB434788-1A1F-42F6-BF46-7CD2F8E29A29}.png)
### 4.总结
![alt text](/操作系统/picture/{A7C139ED-C7A7-4F94-8751-46852FB5A9AD}.png)

## 三、进程控制
进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。即进程控制就是要实现进程状态转换。
![alt text](/操作系统/picture/{C1DCF31E-E4C8-4B3C-AE37-5256AB7A26E3}.png)
![alt text](/操作系统/picture/{D74DE2D8-CDEF-446A-B038-A83D587BFEAC}.png)
### 进程控制相关原语
1. 创建原语
   ![alt text](/操作系统/picture/{EE82697C-37FE-4E67-9E93-D9F6676314DD}.png)
2. 撤销原语
   ![alt text](/操作系统/picture/{77AA3908-DD60-45B3-B602-647E28E36A63}.png)
3. 阻塞原语和唤醒原语
   ![alt text](/操作系统/picture/{6383EA90-1D2E-4BC9-A5EF-366EF8714E83}.png)
4. 切换原语
   ![alt text](/操作系统/picture/{497F74A4-631F-4FF9-8DE5-F6F3AF34E7AF}.png)

> CPU中会设置很多**寄存器**，用来存放程序运行过程中的某些数据。
> PSW：程序状态字寄存器
> PC：程序计数器，存放下一条指令地址
> IR：指令寄存器，存放当前正在执行的指令
> 同用寄存器：其他一些必要信息
> 等等...
   ![alt text](/操作系统/picture/{E1FDD679-3741-47BA-89CA-ADB4099EB6C6}.png)
   当一个进程下CPU时，会被另一个进程覆盖寄存器信息，因此需要*在PCB中保存这个进程的运行环境*（保存一些必要的寄存器信息），存入PCB中。当原进程再次投入运行时，可以通过PCB恢复它的运行环境。
### 总结
![alt text](/操作系统/picture/{6C468C77-D002-4290-8EDE-2520E700292C}.png)

## 四、进程通信
进程间通信（Inter-Process Communication,IPC）是指两个进程之间产生数据交互。
> 进程通信需要操作系统支持 -- 为什么？？？
> 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。各进程只能访问自己的内存地址空间，而无法访问其他进程的内存地址空间。
![alt text](/操作系统/picture/{806F845D-6354-47C2-AE04-A5517032D551}.png)
### 1.共享存储
通过内存中的共享存储区实现共享存储。
![alt text](/操作系统/picture/{C2DF432B-D8E9-4C04-BD5C-7853A03B8D1E}.png)
> 访问应该是互斥的，即一个进程访问共享存储区时，其他进程不可访问，每次只可一个进程访问共享存储区，这样避免同时进行错误（例如同时对共享存储区的某块地址进行写操作，会造成数据覆盖、丢失）。
1. 基础存储区的共享
    操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。
2. 基础数据结构的共享
    例如共享空间只能方一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
### 2.消息传递
![alt text](/操作系统/picture/{D1E88D5D-6055-4F75-BEF0-06B7C7A4C618}.png)
1. 直接通信方式
    ![alt text](/操作系统/picture/{9CFFB8C3-6FF9-4C6A-9B2B-D9C011982841}.png)
2. 间接通信方式
    ![alt text](/操作系统/picture/{562E3BB7-40BA-43C5-9D3F-2927906F9244}.png)
### 3.管道通信
![alt text](/操作系统/picture/{AE1A33B3-8155-4118-AA93-440B81AE037C}.png)
和共享存储类似，都是在内存中开辟一个大小固定的内存空间，但是共享存储大的方式只管分配内存空间，不管数据存储的方式和类型，而管道通信时队列，类似queue，先进先出，一段时间内只可单向。  
> 写进程往管道写数据，即便管道没被写满，*只要管道没空，读进程就可以从管道读数据*
> 读进程从管道读数据，即便管道没被读空，*只要管道没满，写进程就可以往管道写数据*
### 4.总结
![alt text](/操作系统/picture/{6CB95E67-EF2E-45D2-A285-71999147B75A}.png)

## 五、信号
![alt text](/操作系统/picture/{A72BEB66-970D-4898-ABDF-48E625D48B1F}.png)
### 1.信号的作用
信号：用于*通知进程某个特定事件已经发生*。进程收到一个信号后，对该信号进行处理。
![alt text](/操作系统/picture/{7A0C0AAF-7888-441C-8560-B523CB48F43B}.png)
### 2.信号实现原理
1. 信号的发送与保存
    ![alt text](/操作系统/picture/{5FA6A2AF-B299-44E9-A99F-BADADDFF9ED1}.png)
2. 信号的处理
    - 当进程从内核态转为用户态时（例如：系统调用返回、或中断处理返回时），例行检查是否有待处理的信号，如果有，就处理信号。
    ![alt text](/操作系统/picture/{A04D0EE8-3F3B-437D-A3B8-125FB74286F4}.png)
    ![alt text](/操作系统/picture/{6BB67436-6603-4E50-9707-D29348D7688E}.png)
    > 每个进程都可以有自己的自定义信号处理程序，如果没有，则按操作系统规定的默认处理程序。
    > 每个进程的blocked阻塞信号，也由各进程进行系统调用各自设置。
### 3.信号与异常的关系
![alt text](/操作系统/picture/{D197A609-C1AB-4D8B-8523-73993D92F9B1}.png)
### 4.总结
![alt text](/操作系统/picture/{C9B795C1-3A38-4F75-A6CE-24C6B0BBF10B}.png)

## 六、线程的概念和特点
### 1.什么是线程，为什么要引入线程
有的进程可能选哟同时做很多事情，而传统的进程只可串行地执行一系列程序。为此，引入了线程，来增加并发度。  
传统地进程是程序执行流地最小单位。  
引入线程后，C程序执行流的最小单位就不是进程了，而是线程，一个进程可以包含多个线程。
> 可以把线程理解为“轻量级进程”。
![alt text](/操作系统/picture/{48C1D1EA-F5EB-47A1-AB84-EE25A7456744}.png)
> 线程是一个基本的CPU执行单元，也是程序执行流的最小单位。
> 引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提高了系统的并发度，使得一个进程内也可以并发的处理各种任务（如QQ视频、文字聊天、传输文件等）。
> 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。
![alt text](/操作系统/picture/{E869CF0B-E1ED-4238-9F38-CA66FC547A9F}.png)
### 2.线程的属性
![alt text](/操作系统/picture/{B445C217-E079-4EFB-946B-D40DCE45421A}.png)

## 七、线程的实现方式和多线程模型
![alt text](/操作系统/picture/{0BBE106A-B142-4980-AE45-83596DF9B9C1}.png)
### 1.用户级线程（User-Level Thread,ULT）
![alt text](/操作系统/picture/{8C4FA0E9-32C3-4DD8-BC5F-6C46D4B35245}.png)
![alt text](/操作系统/picture/{DC28DE03-78F8-4E9C-8FA9-4124EDB5D9F0}.png)
### 2.内核级线程（Kernel-Level Thread,KLT,又称“内核支持的线程”）
![alt text](/操作系统/picture/{C833FD45-FC2C-463C-8E03-7D5F04247B8A}.png)
### 3.多线程模型
1. 一对一模型
![alt text](/操作系统/picture/{76B24742-1716-4ED4-AF31-64622AB96EA4}.png)
2. 多对一模型
![alt text](/操作系统/picture/{B29EA9C1-4455-4E74-91E3-1870FDE44E30}.png)
3. 多对多模型
![alt text](/操作系统/picture/{4CBB4235-7780-4A3C-A411-EEE139520068}.png)
### 4.总结
![alt text](/操作系统/picture/{52DC8310-310D-4554-8A1C-BCB1B1EEB4F4}.png)

## 八、线程的状态与转换、组织与控制
![alt text](/操作系统/picture/{65901616-32D2-4D00-993D-286A0A50CD11}.png)
![alt text](/操作系统/picture/{32BD3336-6E3B-42A0-AD97-2C64D18A2723}.png)
> 线程这两个部分和进程类似

## 九、处理机调度概念、层次
### 1.调度的基本概念
当有一堆任务要处理时，但由于资源有限，这些事情没办法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。
### 2.调度的三个层次
1. 高级调度（作业调度）
    - 作业：一个具体的任务
    - 用户向系统提交了一个作业 = 用户让操作系统启动一个程序（来处理一个具体的任务）。
    > 高级调度。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。
2. 低级调度
    > 低级调度（进程调度/处理机调度）--按照某种策略从就绪队列中选取一个进程，将处理机分配给它。
    ![alt text](/操作系统/picture/{0856861B-C947-45E9-B117-C4E0B8B6BB1A}.png)
    - 低级调度的频率很高，一般几十毫秒一次，所以宏观上看是同时运行，即满足操作系统并发的特性。
3. 中级调度
    ![alt text](/操作系统/picture/{FE970BBB-5ACB-4CBC-B101-5B91E82C129A}.png)
### 3.进程的挂起态与七状态模型
![alt text](/操作系统/picture/{1DB8A966-C7D9-47DB-8A40-FDCB32C40DC2}.png)
### 4.三层调度的联系、对比
![alt text](/操作系统/picture/{0715AD4A-FDF1-4191-88A9-A04EABED6DB5}.png)
### 5.总结
![alt text](/操作系统/picture/{95FE35C8-864F-4A61-839C-5D894D4C8688}.png)

## 十、进程调度的时机切换与过程调度方式
### 1.进程调度的时机
![alt text](/操作系统/picture/{07D2C07A-0636-4B7C-A7EB-29FE33650AA9}.png)
![alt text](/操作系统/picture/{FB4BBF5E-9128-47C4-A6E1-433E88656ECD}.png)
> 普通临界区访问的临界资源不会影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。
### 2.进程调度的方式
![alt text](/操作系统/picture/{0EFB9304-3216-4260-BDB4-00C326906DEA}.png)
### 3.进程的切换与过程
![alt text](/操作系统/picture/{7C21B275-FD5E-455B-95F0-3799AFBCFBFF}.png)
### 4.总结
![alt text](/操作系统/picture/{509A102E-A3DF-4713-96C6-7824411D11D4}.png)

## 十一、调度器/调度程序
![alt text](/操作系统/picture/{0A786E8C-D7AA-4CFE-B1FA-6B603ADC03E8}.png)
> 不支持内核级线程的操作系统，调度程序处理的对象时进程
> 支持内核级线程的操作系统，调度程序的处理对象我是内核线程

![alt text](/操作系统/picture/{5812B6AE-DCFB-4479-ACC2-3BB3A7B5EC18}.png)

## 十二、调度算法的评价指标
### 1.CPU利用率
![alt text](/操作系统/picture/{DBA6E7AB-6327-422F-AEEA-3E29D27B3BB2}.png)
### 2.系统吞吐量
![alt text](/操作系统/picture/{0807BEC0-B425-49F4-A8A7-DA52B223D5C9}.png)
### 3.周转时间
![alt text](/操作系统/picture/{F0A4B6B2-6BC1-400D-81B2-47E8A3F1520C}.png)
### 4.带权周转时间
![alt text](/操作系统/picture/{13FEB959-8F32-45A1-9D40-658AD59A5846}.png)
### 5.等待时间
![alt text](/操作系统/picture/{2D35789B-5E5F-47BC-AE72-BFEFC7358F7F}.png)
### 6.响应时间
响应时间指从用户提交请求到首次产生响应所用的时间
### 7.总结
![alt text](/操作系统/picture/{D4F69B51-E08B-41EE-9AF1-41805C1ADDDE}.png)

## 十三、调度算法（上）
### 算法思想
1. 先来先服务（FCFS，First Come First Serve）
![alt text](/操作系统/picture/{98C22562-FB3B-4FDF-AD4A-31513CF409FE}.png)
> 可以看见P3的带权周转时间很大，为8，所以体验很差
- 总结
![alt text](/操作系统/picture/{D133FE05-6858-4539-A968-C0BC7FCC7291}.png)
2. 短作业优先（SJF，Shortest Job First）
- 非抢占式
![alt text](/操作系统/picture/{B9336E03-B615-4741-9557-BF18DC4EF1CF}.png)
- 抢占式
![alt text](/操作系统/picture/{9597D6DB-0A6A-4E78-9D39-30D3CA6F881F}.png)
- 注意  
![alt text](/操作系统/picture/{076DA7CD-9C3B-4BDE-940D-B8FB3AFD1B5D}.png)
- 总结
![alt text](/操作系统/picture/{B31FF026-CA96-4A9C-9E2C-56630B8D0E40}.png)
3. 对FCFS和SJF两种算法的思考
![alt text](/操作系统/picture/{20FACC2D-D0AC-44BE-A8DB-AF7118F14C8A}.png)
4. 高响应比优先（HRRN,Hightest Response Ratio Next）
![alt text](/操作系统/picture/{F621F7A9-929C-4647-ABBA-35BB0904349B}.png)
- 总结
![alt text](/操作系统/picture/{7A6ABE32-34A3-4788-BA7E-B486227FEB85}.png)
### 总结
![alt text](/操作系统/picture/{6BCA20CC-C8F5-40F0-9F89-AC9E69AEB654}.png)

## 十四、调度算法（下）
### 算法思想
1. 时间片轮转（RR，Round-Robin）
![alt text](/操作系统/picture/{51BEDA8C-28DA-4272-9BA1-2773A1ADD5A2}.png)
![alt text](/操作系统/picture/{190524AA-8644-4E29-960B-3A0300E568F0}.png)
- 总结
![alt text](/操作系统/picture/{A10EEF74-A670-4BDD-964E-A004E2032340}.png)
2. 优先级调度算法
- 非抢占式
![alt text](/操作系统/picture/{C8F6EC3C-251E-447F-BF92-3388A2FB2E84}.png)
- 抢占式
![alt text](/操作系统/picture/{D529C978-ED4A-411F-A88C-82DF382F19CD}.png)
- 补充
![alt text](/操作系统/picture/{16874959-4FD9-4932-9C6C-5B897B342CD3}.png)
- 总结
![alt text](/操作系统/picture/{F3E54D7A-33B1-45B2-9B99-3ED0AB428B29}.png)

> ![alt text](/操作系统/picture/{5C5C3480-206E-4581-8AD9-5C003D2A8E0B}.png)

3. 多级反馈队列调度算法
![alt text](/操作系统/picture/{ABDF3CE7-4BA2-4912-881D-EA6B1B419F59}.png)
- 总结
![alt text](/操作系统/picture/{89CC4402-0DFF-4ACE-B9D5-E513B211EDA1}.png)
### 总结
![alt text](/操作系统/picture/{88C69D1B-58C3-4170-A39E-CC6D31DA9834}.png)

## 十五、多级队列调度算法
![alt text](/操作系统/picture/{A2EDD2D5-EFF6-4492-B73C-DADE0C86B0E3}.png)

## 十六、多处理机调度
### 多处理机调度相对单处理机调度面临的问题
![alt text](/操作系统/picture/{061DDA1A-FE0B-4EA7-805D-1F3448B4CCD6}.png)
![alt text](/操作系统/picture/{2DD721F3-37A3-4A85-B6AA-4676CC15DC6D}.png)
### 解决
1. 公共就绪队列
![alt text](/操作系统/picture/{1D04BA84-2475-4391-A41E-AB66CA674205}.png)
2. 私有就绪队列
![alt text](/操作系统/picture/{B66556E0-A6A9-48CC-B590-E9D8A9811CD3}.png)
![alt text](/操作系统/picture/{0DA35224-E953-4440-8464-995474956A31}.png)
> 私有就绪队列天然地实现了“处理机亲和性”，但是在处理负载均衡时，会牺牲一部分亲和性，这时，同样可以采用硬亲和地策略，有进程进行系统调用，保证进程地亲和性。
### 总结
![alt text](/操作系统/picture/{18EFB367-F9D0-4C71-A8E3-9E5A6558220F}.png)

## 十七、进程同步、互斥
知识点回顾：进程具有异步性地特征，即各并发执行的进程以各自独立的、不可预知的速度向前推进。
![alt text](/操作系统/picture/{3B369CBC-295B-45CD-900B-30261C6DD6A7}.png)

### 进程同步
![alt text](/操作系统/picture/{23817294-205B-4CEB-AD65-F46E5F322AE9}.png)
### 进程互斥
![alt text](/操作系统/picture/{4BED9824-9A4D-41D7-A34B-3C9BC61B4573}.png)
![alt text](/操作系统/picture/{49680E96-2871-443F-B191-D7871E05B5A0}.png)
![alt text](/操作系统/picture/{D7540A26-C39F-45D1-91A9-077FFC937FBC}.png)
### 总结
![alt text](/操作系统/picture/{656098A7-C3F4-4485-AE0D-D2E8CA1E33F8}.png)

## 十八、进程互斥的软件实现方法
没有进程互斥机制的后果：
![alt text](/操作系统/picture/{32C5881D-CC53-4325-978A-90D7B69F0027}.png)
### 1.单标志法
![alt text](/操作系统/picture/{FAAD3AEF-28A9-48E4-A05A-7EC4EAEEBE2F}.png)
> 缺点：违背“空闲让进”的原则。
### 2.双标志先检查法
![alt text](/操作系统/picture/{77EFDEEA-FD97-4544-A389-247D428C192D}.png)
> 缺点：违反“忙着等待”原则。
### 3.双标志后检查法
![alt text](/操作系统/picture/{6848FA0A-8B0A-4E31-841E-DFFE8974AC93}.png)
> 缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。
### 4.Peterson算法
![alt text](/操作系统/picture/{FBD28B02-8B9E-44DC-AA2E-E82B67A05DBB}.png)
> Peterson算法利用软件方法解决了进程互斥的问题，遵循了空闲让进，忙则等待、有限等待三个原则，但依然未遵守让权等待的原则。
### 5.总结
![alt text](/操作系统/picture/{992487B1-6921-4CE7-A7F7-DEAE46BD3C10}.png)

## 十九、进程互斥的硬件实现方法
### 1.中断屏蔽方法
![alt text](/操作系统/picture/{6222D1B6-63AE-4B40-8B1F-99ADB293E15A}.png)
### 2.TestAndSet方法
![alt text](/操作系统/picture/{EEC91189-2DF1-49F6-9F07-A02E379D1735}.png)
### 3.Swap指令
![alt text](/操作系统/picture/{524D109D-DD1E-483B-9506-F003FCCA8C19}.png)
### 4.总结
![alt text](/操作系统/picture/{FFCC68D4-57E8-48A3-A73E-6B0E3E8CACE3}.png)

## 二十、互斥锁
![alt text](/操作系统/picture/{7F07215A-879F-42A4-81E4-7EF954ED6432}.png)
![alt text](/操作系统/picture/{1BC3751D-4067-4D20-ADC9-74CB700FDD5C}.png)

## 二十一、信号量机制
![alt text](/操作系统/picture/{FF518637-96D3-4B9B-A272-4CC607E519F0}.png)
### 1.信号量机制定义
![alt text](/操作系统/picture/{9702377A-4E02-4291-BE55-5121792F10E2}.png)
1. 整型信号量
用一个整数表示系统资源的变量，用来表示系统中某种资源的数量
~~~c++
// eg：某计算机系统只要一台打印机
int S=1;
void wait(int &S){ //wait原语，相当于：进入区
  while(S<=0); //如果资源数不够，就一直循环等待
  S=S-1;    //如果资源数够，则占用一个资源
}
​
void signal(int &S){//signal原语，相当于“退出区”
  S=S+1;    //使用完资源后，在退出区释放资源
}

进程P0：
wait(S); // 进入区，申请资源
{}// 使用打印机资源代码
signal(S) // 退出区，释放资源

进程P1：
wait(S); // 进入区，申请资源
{}// 使用打印机资源代码
signal(S) // 退出区，释放资源

/*
   ......其余进程
*/

进程Pn：
wait(S); // 进入区，申请资源
{}// 使用打印机资源代码
signal(S) // 退出区，释放资源
~~~
> wait原语，“检查”和“上锁”一气呵成，避免并发、异步导致的问题
> 缺点：可能会出现盲等。
2. 记录型信号量
记录型数据结构表示的信号量
~~~c++
//记录型信号量的定义
typedef struct{
  int value;
  struct process *L;
} semaphore;
//某进程需要使用资源时，通过wait原语申请
void wait (semaphore S){
  S.value--;
  if(S.value<0){
    block (S.L);//将该进程加入到等待队列中，置为阻塞态
 }
}
//进程使用完资源后，通过signal原语释放
void signal (semaphore S){
  S.value++;
  if(S.value<=0){ //s.value为负数，说明有|value|个阻塞态的进程
    wakeup(S.L); // 唤醒等待队列中阻塞态进程
 }
}
~~~
> 除非特别说明，否则默认S为记录型信号量
> ![alt text](/操作系统/picture/{2B7C71F6-D77F-4FD2-9DEF-3B3E70193257}.png)

### 2.总结
![alt text](/操作系统/picture/{6A57FAFC-709D-4010-8848-24B1EF38BFFF}.png)

## 二十二、用信号量机制实现进程互斥、同步、前驱关系
![alt text](/操作系统/picture/{8B93164C-6033-4CB4-8193-3FDD3796FD8A}.png)
### 1.实现进程互斥
![alt text](/操作系统/picture/{CD25CC5F-D613-40DB-9B3A-7143B3D05605}.png)
### 2.实现进程同步
![alt text](/操作系统/picture/{F1ECD47D-EDD5-40A8-8330-B3E98C189E8F}.png)
### 3.实现前驱关系
![alt text](/操作系统/picture/{13C46257-916E-44F0-946B-E6A5C79B4545}.png)
### 4.总结
![alt text](/操作系统/picture/{00BA714B-6624-4BFA-897F-CB683D9EC42D}.png)

## 二十三、生产者消费者问题
### 问题描述
![alt text](/操作系统/picture/{F8229727-22A4-4F80-AC55-F7E6B982E9CB}.png)
### 问题实现
![alt text](/操作系统/picture/{32545A89-511B-4E65-AB9F-5C3D0F475CBD}.png)
### 思考
![alt text](/操作系统/picture/{435C2832-86C9-4F6B-9940-3ACC3780545D}.png)
> 要保证临界区代码简短，避免将生产产品和使用产品放入临界区，放入临界区会不利于各进程并发使用临界区资源，会对性能造成影响
### 总结
![alt text](/操作系统/picture/{0DC2F21F-2C5C-4CE6-A178-1793B1F190B7}.png)

## 二十四、多生产者、多消费者问题
![alt text](/操作系统/picture/{F5D2C3AC-BC70-49E2-BACD-3732F2D8E48B}.png)
![alt text](/操作系统/picture/{D8077138-D355-4809-8D1D-C0DC9DECCAF6}.png)
> 在生产-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区。缓冲区大小大于1，则必须设置互斥信号量。
### 总结
![alt text](/操作系统/picture/{86BC31A2-4C93-4370-88FF-EA5F33434D5F}.png)

## 二十五、读者-写者问题
![alt text](/操作系统/picture/{113BFE3C-361A-46DA-A1BA-7C4F5C6338C1}.png)
![alt text](/操作系统/picture/{E1FD583E-66EF-44EC-A092-3DD27D9B2947}.png)
### 总结
![alt text](/操作系统/picture/{71D4E2F6-757E-43EE-8BE6-572852769D35}.png)

## 二十六、哲学家进餐问题
![alt text](/操作系统/picture/{B5A330C5-0567-4F89-AED7-02AB50A09967}.png)
### 解决方案：
1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。
2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。
3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。
~~~c++
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1; //互斥地取筷子
Pi(){     //i号哲学家的进程
  while(1){
    P(mutex);
    p(chopstick[i]);   //拿右
    p(chopstick[(i+1)%5]);//拿左
    V(mutex);
    吃饭...
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
    思考...
 }
}
~~~
### 总结
![alt text](/操作系统/picture/{E74EFD91-1E18-4E24-BDFE-FB1F28CDB303}.png)

## 二十七、管程
### 1.为什么要引入管程
信号量机制存在的问题：编写程序困难，易出错（PV操作容易出错、困难）。
### 2.管程的定义和基本特征
1. 定义：
- 局部于管程的共享数据结构说明
- 对该数据结构进程操作的一组过程
- 对局部于管程的共享数据设置初始值的语句
- 管程有一个名字
> 可以看到类似于c++中的类
2. 基本特征：
- 局部于管程数据结构只能被局部于管程的过程所访问
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
- 每次仅允许一个进程在管程内执行某个内部过程
![alt text](/操作系统/picture/{12F5C4D8-D353-4118-8E1D-047C736AE804}.png)
### 3.用管程解决生产者消费者问题
![alt text](/操作系统/picture/{13C0C7C1-4189-47BF-8290-313446391152}.png)
### 4.Java中类似于管程的机制
![alt text](/操作系统/picture/{250BFFD9-6B75-4642-BBEE-E8C6817459AC}.png)
### 5.总结
![alt text](/操作系统/picture/{7284CF05-AD6C-4C87-8479-C0E044C395DE}.png)

## 二十八、死锁
### 1.什么是死锁
定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
区别：至少两个或两个的进程同时发生死锁
### 2.饥饿
定义：由于长期得不到想要的资源，某进程无法向前推进的现象。
区别：可能只有一个进程发生饥饿
### 3.死循环
定义：某进程执行过程中一直跳不出某个循环的现象。
区别：死循环是程序逻辑bug或者故意设计的
### 4.区别
![alt text](/操作系统/picture/{E5AC64B4-F8AC-4107-A8E6-381BDA011D33}.png)
### 5.死锁产生的必要条件
- 互斥条件：多个进程争夺资源发生死锁
- 不剥夺条件：进程获得的资源不能由其它进程强行抢夺
- 请求和保持条件：某个进程有了资源，还在请求资源
- 循环等待条件：存在资源的循环等待链
![alt text](/操作系统/picture/{E493F3F7-4177-4CE2-83D1-D13CC10B5CF8}.png)
### 6.什么时候会发生死锁
- 对系统资源的竞争
- 进程推进顺序非法
- 信号量的使用不当也会造成死锁
![alt text](/操作系统/picture/{73F95D7E-11BE-4AA3-81DC-7DDAC652AFB9}.png)
### 7.死锁的处理策略
![alt text](/操作系统/picture/{87BDE19D-E971-4D4D-8F69-D5AB98A6E75C}.png)
### 8.总结
![alt text](/操作系统/picture/{30CDD4AE-7C30-4A84-8011-D276AE8BA091}.png)

## 二十九、死锁的处理策略-预防死锁
### 1.破坏互斥条件
![alt text](/操作系统/picture/{E4A2B133-1DFC-4DDD-8253-88C86EB5B07A}.png)
### 2.破坏不剥夺条件
![alt text](/操作系统/picture/{EF10EDC2-3811-42AD-B8FF-8E33798A3292}.png)
### 3.破坏请求和保持条件
![alt text](/操作系统/picture/{0F608BA0-2C73-4F9D-8733-02216B31AF27}.png)
### 4.破坏循环等待条件
![alt text](/操作系统/picture/{3420858C-FB12-45A7-BDDB-206423B24EFC}.png)
### 5.总结
![alt text](/操作系统/picture/{EE1B3F24-F878-45CD-B02F-9D0ACB8AAE16}.png)

## 三十、死锁的处理策略-避免死锁
### 安全序列
指如果系统按照这种序列分配资源，则每个进程都可以顺利完成。只要找到一个安全序列，系统就是安全状态。当然，安全序列可能有多个。  
如果分配了资源，无法找到任何一个安全序列，系统就进入不安全状态。这就意味着可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也可能重新回到安全状态，不过我们在分配资源之前总是要考虑最坏的情况。  
> 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）。
> 因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是”银行家算法“的核心思想。
### 银行家算法
![alt text](/操作系统/picture/{DA0F0365-C44C-457F-8D2D-3872F206D992}.png)
![alt text](/操作系统/picture/{532A0A69-4918-4E36-8415-7F605D4494EE}.png)
![alt text](/操作系统/picture/{D10AF578-285F-4A27-90F6-3247CA0B480C}.png)
流程：
![alt text](/操作系统/picture/{AA1C3051-2CD7-4AF2-9EEB-73ED057E545A}.png)

初始分配完成后，优先全部分配给最少的，并且拿回资源
		步骤：

			1、检查此次申请是否超过了之前声明的最大需求数

			2、检查此时系统剩余的可用资源是否还能满足这次请求

			3、试探着分配，更改各数据结构

			4、用安全性算法检查此次所分配是否会导致系统进入不安全状态

## 三十一、死锁的处理策略-死锁的检测和解除
![alt text](/操作系统/picture/{32711BC9-F285-4C62-85A9-7ECDD18B02F4}.png)
### 死锁的检测
![alt text](/操作系统/picture/{724A3E07-8236-4D59-8AA0-0A962C42F010}.png)
![alt text](/操作系统/picture/{1BAD4EF7-E360-406B-8639-751DF94EAAF6}.png)
![alt text](/操作系统/picture/{CBE14484-58A9-489B-B1C8-047A2B0D6872}.png)
### 死锁的解除
1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。  
2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。  
3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。
![alt text](/操作系统/picture/{746778B4-74E7-4EF1-A2F9-673873B179A2}.png)
### 总结
![alt text](/操作系统/picture/{A001E5BE-CC46-4F47-A7B9-A9B58F7537A8}.png)

# 第三章 内存管理

## 一、内存的基础知识
内存可存放数据，程序本体在外存上，当程序执行时，需要先将程序放到内存中才能被CPU处理。因为CPU访问外存数据慢，同时CPU处理计算很快，这样做是为了缓和CPU和硬盘之间的速度矛盾。
### 1.什么是内存
![alt text](/操作系统/picture/{E1C462F0-A094-495B-B8AB-E81283B26631}.png)
### 2.内存的数量单位
![alt text](/操作系统/picture/{FD47F6E8-2EB1-4507-BCD4-6E02C8AC1D53}.png)
### 3.指令的工作原理
![alt text](/操作系统/picture/{63F4ABB2-1287-43F4-AE74-ACF8EA44A199}.png)
![alt text](/操作系统/picture/{F0DF8186-DF56-4614-8843-AEB9B9E9CB73}.png)
![alt text](/操作系统/picture/{CDA876AA-80FB-4994-A72A-DF17A5AF3E95}.png)
> 如何将指令中的逻辑地址转换为物理地址？？？
- 1.绝对装入
    在编译的时候就知道程序放在内存的哪个位置，灵活性很差，只适用于单道批处理系统，且不可移植到另一台电脑。
    ![alt text](/操作系统/picture/{03208F6F-D3C5-41A0-A691-7E4EEB82F89D}.png)
- 2.静态重定位
    装入时将逻辑地址转表为物理地址，分配给进程的内存必须连续，必须分配其要求的全部内存空间。其在进程运行期间，不可移动。
    ![alt text](/操作系统/picture/{F7636987-FE99-4D8C-BD13-533DCE5B094B}.png)
- 3.动态重定位
    ![alt text](/操作系统/picture/{637CE1FE-C76E-4B76-83B8-AD450EC6A0A3}.png)
### 4.从写程序到程序运行
![alt text](/操作系统/picture/{C4B669E2-1F19-462A-B175-54C1FC6AB3A0}.png)
> 如何链接个模块？？？
![alt text](/操作系统/picture/{DCFF4B6D-B370-4A9C-B65D-32CF9F1C9647}.png)
### 5.总结
![alt text](/操作系统/picture/{92E073F7-D5A3-4F21-AD6F-ED0FD4DC7A19}.png)

## 二、内存管理
1. 内存空间的分配与回收
2. 内存空间的扩充--虚拟技术（操作系统的虚拟性）
3. 地址转换--逻辑地址和物理地址转换（上一节三种装入方式）
4. 存储保护（保证进程只可随意访问自身所分配的内存空间）
    - 在CPU中设置上、下限寄存器：存放进程上、下限地址。进程指令要访问某个地址时，CPU检查是否越界
    - 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查。重定位寄存器中存放大的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。
### 总结
![alt text](/操作系统/picture/{4489A13D-0045-409C-AFA3-B7FC60FE7E9B}.png)

## 三、进程的内存映像
![alt text](/操作系统/picture/{98B12A57-EF40-43A8-953B-3CBB26AD844A}.png)

## 四、覆盖与交换
![alt text](/操作系统/picture/{87146F42-F554-4A8D-B987-EB0A7745C157}.png)
### 覆盖技术
将程序分为多个段，内存分为”固定区“和”覆盖区“，需要常驻段的放在”固定区“，调入后就不再调出，不常用的段放在”覆盖区“，需要用到时调入内存，用不到时掉出内存。
> 按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区
![alt text](/操作系统/picture/{3D520111-F88B-4CCB-BFCB-F6B3B5AD3A94}.png)
### 交换技术
内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB会常驻内存，不会被患处），即进程在内存和磁盘空间动态调度。  
中级调度（内存调度）就是决定把那个进程从外存调入内存。  
暂时换出外存等待的进程状态为挂起态，挂起态进一步细分为就绪挂起和阻塞挂起。
![alt text](/操作系统/picture/{C13DBE9A-4A71-4AE7-87EA-AD0622C1834E}.png)
### 总结
![alt text](/操作系统/picture/{2E217F2A-2A5C-4337-AA94-DECE8416BE73}.png)

## 五、连续分配管理方式
![alt text](/操作系统/picture/{D01F1715-AD06-420D-8800-1798F45D896B}.png)
### 单一连续分配
![alt text](/操作系统/picture/{AA910D45-0B5A-49CF-94D3-62B10A176D9F}.png)
### 固定分区分配
![alt text](/操作系统/picture/{38F32E56-1A47-44C8-B47D-55BAAA4E7DB3}.png)
![alt text](/操作系统/picture/{5CE458D4-C5BC-4F9F-BDEA-8B1E24115560}.png)
### 动态分区分配
可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。
**问题**
   - 系统用什么数据结构记录内存的使用情况？
    ![alt text](/操作系统/picture/{35A5765B-03AA-40CF-882C-DD09B290B029}.png)
   - 当很多个空闲分区都满足进程内存需求，应该选择哪个分区进行分配？
    ![alt text](/操作系统/picture/{CC5A8034-E40A-4032-A8D7-B4F283F35D4F}.png)
   - 如何进行分区的分配和回收操作？
    *分配*：
    ![alt text](/操作系统/picture/{3C9C87BF-21D3-4E6F-A3F0-680A5345F5F3}.png)
    ![alt text](/操作系统/picture/{A1B17103-57B5-494C-BF3E-7F26E6861D0D}.png)
    *回收*
    ![alt text](/操作系统/picture/{694DA12A-1000-49FA-8A49-D6FC2F190FD7}.png)
    ![alt text](/操作系统/picture/{1404E713-52DF-4607-8C01-D885D1059EAA}.png)
    ![alt text](/操作系统/picture/{CA434C86-0051-4670-9602-721359D386D0}.png)
    ![alt text](/操作系统/picture/{DF9D855C-6E6F-4903-A275-8CDD63F0A5F8}.png)
**内部碎片和外部碎片**
    ![alt text](/操作系统/picture/{E9CEC613-9B42-48EC-B36E-FBD911A8283A}.png)
### 总结
![alt text](/操作系统/picture/{87BB68BA-5040-4033-89DC-B6DFBAD77C7E}.png)

## 六、动态分区分配算法
### 1.首次适应算法
算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区  
如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能满足要求的第一个空闲分区。
### 2.最佳适应算法
算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。  
如何实现：空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链或空闲分区表  
缺点：每次都选最小的分区进行分配，会留下越来越多很小难以利用的内存块。因此会产生很多外部碎片
### 3.最坏适应算法
算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区。
如何实现：空闲分区按容量递减次序链接，分配内存时顺序查找空闲分区链或空闲分区表  
缺点：每次都选择最大分区分配，会让大分区快速被使用完，这样会造成后续大进程没有足够的空间
### 4.邻近适应算法
![alt text](/操作系统/picture/{B1CCBE63-EC80-41AC-BD86-280B68F8EB4E}.png)
### 5.总结
![alt text](/操作系统/picture/{81532D6A-FCDE-4AF3-9DFC-DEA336C34041}.png)

## 七、基本分页存储管理的基本概念
![alt text](/操作系统/picture/{324DC7FD-440A-4777-B8AC-BBD3A2B777B1}.png)
### 1.分页存储
![alt text](/操作系统/picture/{CD53F1A9-7BB4-406A-810E-E5C3ED883EA6}.png)
### 2.重要的数据结构--页表
![alt text](/操作系统/picture/{42C5CE03-B733-43B9-BF4E-BE44CB1E7274}.png)
![alt text](/操作系统/picture/{2FCA8F72-B45F-4A37-908D-54BE0341AF25}.png)
![alt text](/操作系统/picture/{EA64C0C9-DB9B-48A7-A24B-5A01388AF842}.png)
> 只有快号占用内存空间，页号不占
> 页表记录的只是内存块号，而不是内存块的起始地址。j号内存块的起始地址 = j * 内存块大小
### 3.分页存储如何实现地址的转换
![alt text](/操作系统/picture/{A6F3CAF4-A932-44ED-A288-4EBCD9642105}.png)
![alt text](/操作系统/picture/{88F82601-E380-476E-9732-705019CAF120}.png)
![alt text](/操作系统/picture/{3F35FC5F-DF86-4362-A786-CD3B356F3D7C}.png)
![alt text](/操作系统/picture/{9A67AC8E-C318-43BA-A9E5-C03E11632669}.png)
![alt text](/操作系统/picture/{FC9602EE-582D-4046-9229-5BD64F43B238}.png)
> 页面大小要取2的整数幂
![alt text](/操作系统/picture/{AB921AF5-EF63-461C-B08E-ED0791EF2B11}.png)
### 4.逻辑地址结构
![alt text](/操作系统/picture/{0FD4F127-B15B-4990-9464-0F80B29BAB20}.png)
### 5.总结
![alt text](/操作系统/picture/{F64E2947-2D02-4A92-BB7D-C633DDF6C7FC}.png)

## 八、基本地址变换机构
![alt text](/操作系统/picture/{705B8AA2-A29F-4E68-9150-3C6B2F3C534B}.png)
页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。
![alt text](/操作系统/picture/{DF4A77E6-FD5A-4A22-A19E-EC835CFBE3CE}.png)
![alt text](/操作系统/picture/{ED3AE051-146C-4E0E-8473-7AD2B1E66B9C}.png)
### 例子
![alt text](/操作系统/picture/{DA48CA04-8D81-4E25-8D43-42B019872D3F}.png)
### 进一步探讨
![alt text](/操作系统/picture/{08352B64-D34B-4996-A3EE-9BC375590F30}.png)
### 总结
![alt text](/操作系统/picture/{E436E63B-AE75-4DD2-BED4-D1CFCF46C7C1}.png)

## 九、具有快表的地址变换机构
是基本地址变换机构的改进版本
### 1.什么是快表（TLB）
快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放最近访问的页表项的副本，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。
### 2.流程
![alt text](/操作系统/picture/{96BFF733-E429-4D56-A3F9-40F785607F8C}.png)
### 3.引入快表后，地址的变换过程
![alt text](/操作系统/picture/{E3ED8FDD-F90D-43BD-AC40-0392ED1B9C3E}.png)
### 4.局部性原理
![alt text](/操作系统/picture/{A4B1F766-F7AF-4590-9B4E-0A27188C37EC}.png)
### 5.总结
![alt text](/操作系统/picture/{43AFAADB-6E7E-4E92-8002-F1B5220EB37B}.png)

## 十、两级页表
1. 单级页表存在什么问题？
所有页表项必须连续存放，页表过大时需要很大的连续空间  
在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存  
2. 如何解决？
![alt text](/操作系统/picture/{6ED424E7-FEAC-4A76-8E98-2CE79B9C549A}.png)
3. 如何实现？
![alt text](/操作系统/picture/{78E3CDDC-1AC6-4F57-8F17-18F5987A0694}.png)
![alt text](/操作系统/picture/{62B78ACE-F9B6-42FA-8F80-6EFABF977441}.png)
### 细节
![alt text](/操作系统/picture/{6B41B98D-043A-4D00-8F6E-7179FD21B15A}.png)
### 总结
![alt text](/操作系统/picture/{DE9A9658-E651-4105-99ED-B8167DDCE660}.png)

## 十一、基本分段存储管理
### 1.什么是分段
![alt text](/操作系统/picture/{D68A7CFD-1030-463D-B2D9-D5908C6DCFA4}.png)
### 2.分段的逻辑结构
![alt text](/操作系统/picture/{48D332E1-753A-4BDD-AB9F-7415F37266ED}.png)
### 3.各段之间建立联系--段表
![alt text](/操作系统/picture/{2343EE1D-001B-44F1-9038-F9D0E9195391}.png)
### 4.地址变换
![alt text](/操作系统/picture/{72F40E5C-5F90-47F5-A048-93D408972390}.png)
> 分段、分页区别：分段需要对偏移量是否越界进行检查
### 5.分段、分页管理的对比
![alt text](/操作系统/picture/{70BC4418-7C09-4FE6-8620-FFEAAD447D10}.png)
![alt text](/操作系统/picture/{1BC3DA6A-268B-4946-A997-CC086FFBBA52}.png)
![alt text](/操作系统/picture/{63A9A7A6-D9A7-4F19-AB15-E88DB388F8AD}.png)
![alt text](/操作系统/picture/{D011AE28-0ADD-4098-BA8C-416DF6E007D5}.png)
### 6.总结
![alt text](/操作系统/picture/{86411E59-6563-4C38-8D8F-5995D28618FB}.png)

## 十二、段页式管理方式
### 1.分页、分段管理方式中最大的优缺点
分页：利用率高，不会产生外部碎片，只会产生少部分内部碎片，不方便进行信息共享和保护  
分段：方便信息共享和保护，如果段长大，容易产生外部碎片，同时，如果段长过大，为其分配很大的连续空间是不方便的
### 2.段页式管理
![alt text](/操作系统/picture/{BCAE5DC9-2C1B-439C-8BD2-E46B9D511DE2}.png)
### 3.逻辑地址结构
![alt text](/操作系统/picture/{0F2ADCC0-FFDC-4314-B42E-4F2C995F8AF1}.png)
### 4.段表、页表
![alt text](/操作系统/picture/{59D28F96-DE0E-4D82-A0F8-269AE945CC0D}.png)
### 5.地址转换
![alt text](/操作系统/picture/{12BA3592-81CF-417C-8594-301CD492E529}.png)
### 6.总结
![alt text](/操作系统/picture/{0B14E483-2E97-4394-9804-0F2561DF25AE}.png)

## 十三、虚拟内存的基本概念
![alt text](/操作系统/picture/{E545E14B-A8B7-4C64-A22C-AF926AEEBB5A}.png)
![alt text](/操作系统/picture/{7E49B008-4883-4CED-A741-32B8956A46CE}.png)
### 1.传统存储管理方式的特征、缺点
![alt text](/操作系统/picture/{EBD70692-A330-4EC7-BB2A-52E5C480AFEB}.png)
> 这些问题都可以用虚拟存储技术解决
### 2.局部性原理
![alt text](/操作系统/picture/{D4A1B978-E6CC-440C-BE97-EF9F1B091EE6}.png)
### 3.虚拟内存的定义和特征
![alt text](/操作系统/picture/{6EB0F88D-AB60-4FBD-92B9-C5D26BD3F355}.png)
### 4.如何实现虚拟内存技术
![alt text](/操作系统/picture/{FEDC6DF7-923E-4412-8872-2B0FFB68F1FF}.png)
### 5.总结
![alt text](/操作系统/picture/{53A75E43-6CBE-4F96-BD29-A64326297430}.png)

## 十四、请求分页存储管理
![alt text](/操作系统/picture/{A409FB7A-862C-498E-9340-FE1D1667D398}.png)
### 1.页表机制
![alt text](/操作系统/picture/{CAAEAB60-6D04-48AF-B5F8-3F6A73BEEA2C}.png)
### 2.缺页中断机构
![alt text](/操作系统/picture/{74298547-C459-4D9C-9EE0-1E738CE84E94}.png)
![alt text](/操作系统/picture/{E226F868-D532-4BE1-99EB-EFCEB9085089}.png)
### 3.地址变换机构
![alt text](/操作系统/picture/{7D05F82D-6B46-47CD-95EB-5BF4FEA9B539}.png)
![alt text](/操作系统/picture/{2B508021-F4EE-47B2-8338-B33ADAFC24AA}.png)
![alt text](/操作系统/picture/{F5E2CBDE-3E84-4864-B032-3E46067F2EE4}.png)
### 4.总结
![alt text](/操作系统/picture/{E9F61954-8237-42E5-BB2E-AAA2DB98EBD4}.png)

## 十五、页面置换算法
决定应该换出哪个页面
> 页面的换入换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率
### 1.最佳置换算法（OPT）
每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
![alt text](/操作系统/picture/{17B9578D-E4C3-463F-8A5D-2753C9A67EAC}.png)
> 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预知页面访问序列。因此，最佳置换算法是无法实现的。
### 2.先进先出置换算法（FIFO）
每次选择淘汰的页面是最早进入内存的页面
![alt text](/操作系统/picture/{23D14F54-BFDA-4CC5-BE4D-0EC78E88AE88}.png)
> Belady异常--当分配的内存块增大时，缺页次数反而增加
### 3.最近最久未使用置换算法（LRU，Least recently used）
![alt text](/操作系统/picture/{AE7A02C7-67F5-49ED-943C-968C694D6C77}.png)
> 需硬件支持，算法开销大
### 4.时钟置换算法（最近未用算法，CLOCK）
![alt text](/操作系统/picture/{4441A80D-4E65-4C99-B3AC-171FCD95EA23}.png)
> 最多经历两轮扫描，初始为1，扫一下为0，再扫一下被踢
### 5.改进型的时钟置换算法
![alt text](/操作系统/picture/{4A7C8323-A5D5-45D7-B84D-1E2A96868142}.png)
### 6.总结
![alt text](/操作系统/picture/{2D0BE4F3-02D0-49D2-AE2A-6BD4123447C0}.png)

## 十六、页面分配策略
### 1.驻留集
指请求分页存储管理中给进程分配的物理块的集合
> 若驻留集太小，会导致缺页频繁，系统要花大量时间处理缺页，实际用于进程推进的时间少；驻留集太大，会导致多道程序并发度下降，资源利用率降低，所以要选择一个合适的驻留集大小。
![alt text](/操作系统/picture/{C029B1DB-8729-4D5B-9E0A-A907AB76F022}.png)
### 2.页面分配、置换策略
![alt text](/操作系统/picture/{EC59DC28-9F3A-44D1-9987-FF8F6A19A2F7}.png)
### 3.何时调入页面
![alt text](/操作系统/picture/{6B1AFBC1-6E01-4DDA-925F-AE2230E31540}.png)
### 4.从何处调入页面
![alt text](/操作系统/picture/{FC049052-D285-4BF4-A990-DF3F96EFE786}.png)
### 5.抖动（颠簸）现象
![alt text](/操作系统/picture/{5CB52256-F444-4392-9852-7B06E31257A8}.png)
### 6.工作集
指在某段时间间隔里，进程实际访问页面的集合
![alt text](/操作系统/picture/{3E213BAF-72BD-44C4-82B9-16A799A17354}.png)
### 7.总结
![alt text](/操作系统/picture/{3A83FF71-6E3C-42D6-9557-3342D7F4D76F}.png)

## 十七、内存映射文件
操作系统向上层程序员提供的功能（系统调用）。
- 方便程序员访问文件数据
    > 传统文件访问方式
    ![alt text](/操作系统/picture/{81134C95-9661-400A-8C77-1C650CF3A6B1}.png)
    > 很麻烦，比较繁琐
    > 内存映射文件方式
    ![alt text](/操作系统/picture/{31BADCA7-0DDB-4C7A-AF7A-D03DC725502C}.png)
- 方便多个进程共享同一份文件
    ![alt text](/操作系统/picture/{70E4997D-15D0-456A-AD4B-12051C04009B}.png)
### 总结
![alt text](/操作系统/picture/{6645800E-7372-4078-A0A4-A762259DB661}.png)

# 第四章、文件管理

## 一、初始文件管理
文件--就是一组有意义的信息/数据集合，文件也属于系统资源。  
> 计算机中存放了各种各样的文件，一个文件有哪些属性？
  - 文件名（同一目录下不允许有重名文件）、标识符（一个系统内的各文件标识符唯一，对用户来说没有可读性，只是操作系统用于区分各个文件的内部名称）、类型、位置、大小、创建时间、上次修改时间、文件所有者信息、保护信息（对文件进程保护的访问控制信息）
> 文件内部的数据应该怎么组织起来
  - 1. 无结构文件
  - 2. 有结构文件
    ![alt text](/操作系统/picture/{4D45962B-A633-4CD9-82C0-E0A991A94B34}.png)
> 文件之间又应该怎么组织起来
  - 通过目录组织起来，目录文件也是有结构文件
    ![alt text](/操作系统/picture/{7623E87C-45BB-40C3-9E99-679A87F87DD9}.png)
> os应该提供哪些功能，才能便于用户、程序使用文件？
  - 创建（creat）、读（read）、写（write）、删除（delete）、打开（open）、关闭（close）...都是系统调用
    ![alt text](/操作系统/picture/{67AF7AB5-BFED-484C-B4E9-B9E516162C21}.png)    
> 文件数据怎么存放在磁盘上？
  - 类似内存
    ![alt text](/操作系统/picture/{6F086C38-38ED-475C-9FB4-8B7F87B362FE}.png)
    ![alt text](/操作系统/picture/{A745A5C2-2552-42B2-B9F8-91DB99F77DEB}.png)
> 其他需要操作系统实现的文件管理功能
    ![alt text](/操作系统/picture/{7E480824-24F1-4448-98A8-641C4924EC41}.png)
### 总结
![alt text](/操作系统/picture/{EF8F8E79-AE37-465E-B1C3-D31693748611}.png)

## 二、文件的逻辑结构
![alt text](/操作系统/picture/{8A816883-F1BA-4B57-9F13-234FD597C3F0}.png)
1. 无结构文件
文件由一系列二进制文件流组成
2. 有结构文件（记录式文件）
![alt text](/操作系统/picture/{D0A81190-5CBB-4007-BD89-E2B86DC16153}.png)
### 1.顺序文件
![alt text](/操作系统/picture/{8D1032E9-7D10-490B-8386-5FB42682938B}.png)
![alt text](/操作系统/picture/{1B89F695-2852-400E-9105-BFA00595ED86}.png)
### 2.索引文件
![alt text](/操作系统/picture/{B30D07A5-B691-4F64-ABF6-06B53C5E32EE}.png)
### 3.索引顺序文件
![alt text](/操作系统/picture/{DB46E4FF-95E4-4860-9BAB-A02684BDCC0D}.png)
![alt text](/操作系统/picture/{776715B1-A5E2-40EF-B2FD-8758474A4BB6}.png)
![alt text](/操作系统/picture/{8570435F-BC25-4E49-AB54-98BCFB8C4593}.png)
### 4.总结
![alt text](/操作系统/picture/{76331A17-E832-4943-B182-0FF47C5D49C3}.png)

## 三、文件目录
![alt text](/操作系统/picture/{660F92DE-437B-47D5-831A-A49F3DD04EF4}.png)
### 1.文件控制块（FCB）
![alt text](/操作系统/picture/{41A665B4-11D7-4771-9A14-5D10955D93D5}.png)
![alt text](/操作系统/picture/{7800FF19-3829-4930-98DF-B48DF18BE4F7}.png)
![alt text](/操作系统/picture/{9B7D56C8-5946-411A-812E-B457AEAC8538}.png)
### 2.目录结构--单级目录结构
![alt text](/操作系统/picture/{327C8449-463E-4D0A-B7C8-BD88FB0EFDFC}.png)
### 3.目录结构--两级目录结构
![alt text](/操作系统/picture/{E13F7E12-4D5A-4D80-A72E-27E08A4453AD}.png)
### 3.目录结构--多级目录结构（树形目录结构）
![alt text](/操作系统/picture/{FD4858C5-32D2-416A-A8A3-B03BD032EAD9}.png)
![alt text](/操作系统/picture/{93A446D9-C377-48DF-820A-E379E7459A2B}.png)
> 树形目录结构可以方便的对文件进行分类，层次结构清晰，也可以更有效的对文件进行管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。
### 4.目录结构--无环图目录结构
![alt text](/操作系统/picture/{403265D0-BA68-4431-9B7C-25862CE1E8CB}.png)
### 5.索引节点（FCB的改进）
![alt text](/操作系统/picture/{D1644090-8E96-42D7-A534-0CDF1F82E6B6}.png)
![alt text](/操作系统/picture/{17456BAF-ABBA-4411-97B2-772B75F9F9ED}.png)
### 6.总结
![alt text](/操作系统/picture/{0F84BE06-B4F9-4733-A7E0-87A5885710BB}.png)

## 四、文件的物理结构（文件分配方式）
文件数据怎么存放在外存中。
### 1.文件快、磁盘块
![alt text](/操作系统/picture/{842131E2-ED17-4247-91BA-4547462588B1}.png)
![alt text](/操作系统/picture/{D7A58F91-0021-4A07-B908-3477DFBBAF01}.png)
### 2.文件分配方式
1. 连续分配
    连续分配方式要求每个文件在磁盘上占有一组连续的块，读写入内存很快，但对文件的拓展不方便，有很多磁盘碎片
    ![alt text](/操作系统/picture/{9C1A00AF-427A-4411-8A86-8CBC0344FBB4}.png)
    ![alt text](/操作系统/picture/{69019780-A05E-42CD-A1DD-52CE4EE9CAC2}.png)
    ![alt text](/操作系统/picture/{5B90A39E-04DE-4F6E-99FE-B152EF74C954}.png)
    ![alt text](/操作系统/picture/{8C85F907-2292-4117-B938-351FBD6C6355}.png)
2. 链接分配
   - 隐式分配：采用链接分配方式的文件，只支持顺序访问，不支持随机访问，方便拓展
    ![alt text](/操作系统/picture/{E20DA916-C61C-4ACF-8225-4B593BB85295}.png)
    ![alt text](/操作系统/picture/{392B836B-F44E-40B4-A72E-5F4743508F5F}.png)
   - 显示分配：文件分配表显式记录下一块物理块的位置，方便拓展，支持随机访问，文件表会占内存空间
    ![alt text](/操作系统/picture/{A82B8D63-7082-4385-8C43-841538A10DCE}.png)
    ![alt text](/操作系统/picture/{C251CD60-F36F-4283-B702-B01C860E1BD6}.png)
   - 总结
    ![alt text](/操作系统/picture/{7578D72F-7D89-46FD-8B08-EA33DDF37D37}.png)
3. 索引分配
   - 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块
    ![alt text](/操作系统/picture/{BDD2B2F1-8907-472A-95EC-A13198D8FFC0}.png)
   - 如何实现逻辑块号到物理块号的转换
    ![alt text](/操作系统/picture/{01A82503-EA32-469C-A1E9-0C2993D73BFB}.png)
   - ![alt text](/操作系统/picture/{85648053-057A-49D3-A8C5-B1E8BAA90D10}.png)
     - 1. 链接方案
        ![alt text](/操作系统/picture/{177806D7-6B74-4E29-B036-E585563768EB}.png)
     - 2. 多层索引  
        ![alt text](/操作系统/picture/{FB862727-C670-4470-9DD6-3A394CE1472C}.png)
     - 3. 混合索引
        ![alt text](/操作系统/picture/{FB30CDDD-66B2-4DB2-A6B0-750AE9FB83A1}.png)
   - 总结
    ![alt text](/操作系统/picture/{02DC505A-C38D-41C6-AF6A-0FDDC8D0F10A}.png)
### 3.总结
![alt text](/操作系统/picture/{6F58B603-3E2B-4C96-A1EC-9B39A1F5896E}.png)

## 五、逻辑结构vs.物理结构
![alt text](/操作系统/picture/{A5C3451C-192B-442E-9CA7-DCCA8DFEAA85}.png)
![alt text](/操作系统/picture/{05B15710-79B5-46A1-AD2A-123A7F5FB0B7}.png)

## 六、文件存储空间管理
对空闲磁盘空间的管理
### 1.存储空间的划分与初始化
![alt text](/操作系统/picture/{06151532-A23C-42B6-AB28-5AE6318FFEC2}.png)
### 2.存储空间管理
1. 空闲表法
    首位置+长度，回收时注意修改。适用于连续分配方式
    ![alt text](/操作系统/picture/{8F083A36-7156-4F3E-A910-7B5D039F46B2}.png)
2. 空闲链表法
    ![alt text](/操作系统/picture/{2ADFED5D-1E9D-4141-BE23-14DC5F8E4F3F}.png)
    1. 空闲盘块链
        ![alt text](/操作系统/picture/{B1D4A6F1-88CB-4AB2-99FB-77735ADD8A43}.png)
    2. 空闲盘区链
        ![alt text](/操作系统/picture/{3F932E59-9EA5-4A52-96FC-C5067E57FF35}.png)
3. 位示图法
    ![alt text](/操作系统/picture/{E78C569B-2825-494B-9CA5-ED5B26AF5A7A}.png)
3. 成组链接法
    文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。
    ![alt text](/操作系统/picture/{3F4F83EB-1A48-4704-B188-AA22BFD64C5E}.png)
### 3.总结
![alt text](/操作系统/picture/{E4D02A9D-F053-45E6-A83A-B6ECE464EB02}.png)

## 七、文件的基本操作
### 1.创建文件
![alt text](/操作系统/picture/{5787B09D-D491-4FC9-8DA5-F4CEEBCEE305}.png)
### 2.删除文件
![alt text](/操作系统/picture/{231D0ADB-555D-4081-B421-BA07B0F119D3}.png)
### 3.打开文件
![alt text](/操作系统/picture/{32627108-4A4C-4BDA-AC7B-0115BBAFAB13}.png)
- 系统的打开文件表（整个系统只有一张）
- 进程的打开文件表
![alt text](/操作系统/picture/{5C15B0BF-88E7-44F9-8811-1C95D85B294D}.png)
### 4.关闭文件
![alt text](/操作系统/picture/{9CBF3049-4CF5-4476-85E0-F8256D8F6670}.png)
### 5.读文件
![alt text](/操作系统/picture/{DBD6717F-7D2F-4CBB-80F1-94E94B9AB33C}.png)
### 6.写文件
![alt text](/操作系统/picture/{2C5A39F6-1E7F-42EA-9DA0-EDF3E5399360}.png)
### 7.总结
![alt text](/操作系统/picture/{B6E3014C-602F-449D-A0D4-A1AD6BF199DE}.png)

## 八、文件共享
![alt text](/操作系统/picture/{23D75C12-0EEA-4ECF-8BD4-4C71DDA6A446}.png)
### 1.基于索引节点的共享方式（硬链接）
![alt text](/操作系统/picture/{DFF00675-28CA-4A31-B411-F7270A3DA777}.png)
### 2.基于符号链的共享方式（软链接）
![alt text](/操作系统/picture/{FAB1856F-B7DC-4848-A15A-FC5697E85C29}.png)
> 删除一个文件，会导致软链接的路径找不到路径，软链接就会失效。
> 软链接访问共享文件要查询多级目录，需要多次磁盘I/O
### 3.总结
![alt text](/操作系统/picture/{19FDD855-EB6D-43B1-932E-5FAA667FB4F6}.png)

## 九、文件保护
### 1.方法
1. 口令保护
![alt text](/操作系统/picture/{02D96489-487A-450F-BD02-2A1471AA7C74}.png)
2. 加密保护
![alt text](/操作系统/picture/{E089B916-6E30-4481-8120-0B60673849E0}.png)
> 优点：保密性强，不需要再系统中存储密码
> 缺点：编译/译码，或者说加密/解密需要花费一定时间
3. 访问控制
![alt text](/操作系统/picture/{2E31EC49-F4CC-462B-AFCC-1EAE8D2B25E1}.png)
### 2.总结
![alt text](/操作系统/picture/{AC94ABAF-9F64-4C6C-A244-EBC3F7D1916A}.png)

## 十、文件系统的层次结构
![alt text](/操作系统/picture/{8314C225-8C62-465F-B781-F9045AE68E7A}.png)
### 例子
![alt text](/操作系统/picture/{9236D78A-6639-4001-9696-30B776412EBA}.png)

## 十一、文件系统的全局结构（布局）
### 文件系统在外存中的结构
1. 物理格式化
![alt text](/操作系统/picture/{0F0A9732-54F2-4406-8159-3DF956B25C6A}.png)
2. 逻辑格式化
![alt text](/操作系统/picture/{BE6AEB08-CA60-4EB1-B9DB-2E5A02169049}.png)
### 文件系统在内存中的结构
![alt text](/操作系统/picture/{F644E1EF-6343-454E-9BA1-400A93B98463}.png)
![alt text](/操作系统/picture/{D1DC8158-E7B6-4A0C-8367-B1FBB72CA079}.png)

## 十二、虚拟文件系统、文件系统挂载（安装）
### 1.虚拟文件系统（VFS）
![alt text](/操作系统/picture/{1EF787B2-2935-4F1C-9212-72E6CD07022F}.png)
![alt text](/操作系统/picture/{8BF3838C-2547-44C3-8790-D30292EDFBCC}.png)
> 对上提供同一接口
> 对下要求各硬件实现VFS的要求
![alt text](/操作系统/picture/{889EA896-7F81-4CD5-AB29-4924448F43E8}.png)
![alt text](/操作系统/picture/{14974ABA-3970-4A73-820C-2E9AC19B3B33}.png)
![alt text](/操作系统/picture/{710C8994-0617-46D9-8129-156459C3AD6E}.png)
### 2.文件系统挂载
![alt text](/操作系统/picture/{21A3AB54-E270-4216-BEA1-2971CD029366}.png)