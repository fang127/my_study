### 3.3
标准库 string 的输入运算符自动忽略字符串开头的空白（包括空格符、换行符、制表符等），从第一个真正的字符开始读起，直到遇见下一处空白为止。  
如果希望在最终的字符串中保留输入时的空白符，应该使用 getline 函数代替原来的 >> 运算符，getline 从给定的输入流中读取数据，直到遇到换行符为止，此时换行符也被读取进来，但是并不存储在最后的字符串中。
### 3.7
就本题而言，将循环控制变量的类型设为 char 不会对程序运行结果造成影响，因为我们使用 auto 自动推断字符串 s 的元素类型，结果同样是 char。
### 3.8
我们希望处理字符串中的每一个字符，且无须在意字符的处理顺序，因此与传统的 while 循环和 for 循环相比，使用范围 for 循环更简洁直观。
### 3.9
不合法，因为初始状态下没有给 s 赋任何初值，所以字符串 s 的内容为空，当然也就不存在首字符，下标 0 是非法的。
### 3.10
不合法。该程序段从语法上来说是合法的，s 是一个常量字符串，则 c 的推断类型是常量的引用，即 c 所绑定的对象值不能改变。但是该段程序不能正确编译，因为 c 是绑定到常量的引用，其值不能改变。
### 3.12
a 正确 默认初始化 b 错误，将vector<int>用来初始化string c 正确，10个null
### 3.13
（a）的元素数量为 0；  
（b）的元素数量为 10，每一个元素都被初始化为 0；  
（c）的元素数量为 10，每一个元素都被初始化为 42；  
（d）的元素数量为 1，元素的值为 10；  
（e）的元素数量为 2，两个元素的值分别是 10 和 42；  
（f）的元素数量为 10，每一个元素都被初始化为空串；  
（g）的元素数量为 10，每一个元素都被初始化为"hi"。
### 3.18
该程序是非法的，因为 ivec 目前没有任何元素，因此 ivec[0] 的形式是错误的，程序试图访问的元素根本不存在。要想向 vector 对象中添加新元素，需要使用 push_back 函数。  
```c++
vector<int> ivec;
ivec.push_back(42);
```
### 3.19
```c++
vector<int> vInt(10, 42);
vector<int> vInt1 = {42,42,42,42,42,42,42,42,42,42};
vector<int> vInt2{42,42,42,42,42,42,42,42,42,42};
vector<int> vInt3;
for (int i = 0; i < 10; i++)
    vInt3.push_back(42);
vector<int> vInt4(10);
for (auto &i : vInt4)
    i = 42;
```
### 3.26
C++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。  
与之相反，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动多少个元素后得到左侧的迭代器，参与运算的两个迭代器必须指向同一个容器中的元素或尾后元素。  
另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。  
在本题中，因为迭代器的加法不存在，所以 mid = (beg + end) / 2; 不合法。mid = beg + (end - beg) / 2; 的含义是，先计算 end - beg 的值得到容器中的元素个数，然后控制迭代器与整数（ (end - beg) / 2 ）进行运算，从开始处向右移动二分之一容器的长度，从而定位到容器中间的元素。
### 3.27
（a）是非法的，buf_size 是一个普通的无符号数，不是常量，不能作为数组的维度。  
（b）是合法的，4*7-14 = 14 是一个常量表达式。  
（c）是非法的，txt_size() 是一个普通的函数调用，没有被定义为 constexpr，不能作为数组的维度。  
（d）是非法的，当使用字符串初始化字符数组时，默认在尾部添加一个空字符 \0，算上这个符号该字符串共有 12 个字符，但是字符数组 st 的维度只有 11，无法容纳题目中的字符串。
### 3.28
与练习 2.10 类似，对于 string 类型的数组来说，因为 string 类本身接受无参数的初始化方式，所以不论数组定义在函数内还是函数外都被默认初始化为空串。  
对于内置类型 int 来说，数组 ia 定义在所有函数体之外，根据 C++ 的规定，ia 的所有元素默认初始化为 0；而数组 ia2 定义在 main 函数的内部，将不被初始化，如果程序试图拷贝或输出未初始化的变量，将遇到未定义的奇异值。
### 3.29
数组与 vector 的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问。  
数组与 vector 的最大不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能较好，但是与 vector 相比损失了灵活性。  
具体来说，数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后把原数组的所有元素复制到新数组中去。数组也无法像 vector 那样使用 size 函数直接获取数组的维度。如果是字符数组，可以调用 strlen 函数得到字符串的长度；如果是其他数组，只能使用 sizeof(array) / sizeof(array[0]) 的方式计算数组的维度。
### 3.30
```c++
constexpr size_t array_size = 10;
int ia[array_size];
for (size_t ix = 0; ix < array_size; ++ix)
    ia[ix] = ix;
```
### 3.31
该程序对 scores 执行了列表初始化，为所有元素赋初值为 0，这样在后续统计时将会从 0 开始计算各个分数段的人数，是正确的做法。  
如果不初始化 scores，则该数组会含有未定义的数值，这是因为 scores 是定义在函数内部的整型数组，不会执行默认的值初始化。
### 3.33
该程序对 scores 执行了列表初始化，为所有元素赋初值为 0，这样在后续统计时将会从 0 开始计算各个分数段的人数，是正确的做法。  
如果不初始化 scores，则该数组会含有未定义的数值，这是因为 scores 是定义在函数内部的整型数组，不会执行默认初始化。
### 3.34
如果 p1 和 p2 指向同一个数组中的元素，则该条语句令 p1 指向 p2 原来所指向的元素。从语法上来说，即使 p1 和 p2 指向的元素不属于同一个数组，但只要 p1 和 p2 的类型相同，该语句也是合法的。  
如果 p1 和 p2 的类型不同，则编译时报错。
### 3.37
程序第一行声明了一个包含 5 个字符的字符数组，因为我们无须修改数组的内容，所以将其定义为常量。第二行定义了一个指向字符常量的指针，该指针可以指向不同的字符常量，但是不允许通过该指针修改所指常量的值。

while 循环的条件是 *cp，只要指针 cp 所指的字符不是空字符 \0，循环就重复执行，循环的任务有两项：首先输出指针当前所指的字符，然后将指针向后移动一位。

该程序的原意是输出 ca 中存储的 5 个字符，每个字符占一行，但实际的执行效果无法符合预期。因为以列表初始化方式赋值的 C 风格字符串与以字符串字面值赋值的有所区别，后者会在字符串最后额外增加一个空字符以示字符串的结束，而前者不会这样做。

因此在该程序中，ca 的 5 个字符全都输出后，并没有遇到预期的空字符，也就是说，while 循环的条件仍将满足，无法跳出。程序继续在内存中 ca 的存储位置之后挨个寻找空字符，直到找到为止。在这个过程中，额外经历的内容也将被输出出来，从而产生错误。
### 3.38
指针也是一个对象，与指针相关的属性有 3 个，分别是指针本身的值（value）、指针所指的对象（content）以及指针本身在内存中存储位置（address）。它们的含义分别是：

指针本身的值是一个内存地址值，表示指针所指对象在内存中的存储地址；  
指针所指的对象可以通过解引用指针访问；  
因为指针也是一个对象，所以指针也存储在内存的某个位置，它有自己的地址，这也是为什么有"指针的指针"的原因。  
通过上述分析我们知道，指针的值是它所指对象的内存地址，如果我们把两个指针加在一起，就是试图把内存中两个对象的存储地址加在一起，这显然是没有任何意义的。与之相反，指针的减法是有意义的。如果两个指针指向同一个数组中的不同元素，则它们相减的结果表征了它们所指的元素在数组中的距离。