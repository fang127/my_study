### 14.1
不同点：

重载操作符必须具有至少有一个 class 或枚举类型的操作数；  
重载操作符不保证操作数的求值顺序。例如，对 && 和 || 的重载版本不再具有 “短路求值” 的特性，两个操作数都要进行求值，而且不规定操作数的求值顺序。

相同点：

对于优先级和结合性及操作数的数目都不变。
### 14.3
（a）"cobble" == "stone" 应用了 C++ 语言内置版本的 == ，比较两个指针。

（b）svec1[0] == svec2[0] 应用了 string 版本的重载 ==。

（c）svec1 == svec2 应用了 vector 版本的重载 ==。

（d）svec1[0] == "stone" 应用了 string 版本的重载 ==，字符串字面常量被转换为 string。
### 14.4
（a）% 通常定义为非成员。

（b）%= 通常定义为类成员，因为它会改变对象的状态。

（c）++ 通常定义为类成员，因为它会改变对象的状态。

（d）-> 必须定义为类成员，否则编译会报错。

（e）<< 通常定义为非成员。

（f）&& 通常定义为非成员。

（g）== 通常定义为非成员。

（h）() 必须定义为类成员，否则编译会报错。

注：复合赋值运算符（+=、-=、*=、/= 和 %=）会改变对象的状态，一般定义为类成员。如练习 14.20 中的 +=
### 14.14
从头实现 operator+ 的方式与借助 operator+= 实现的方式相比，在性能上没有优势，而可读性上后者显然更好。
### 14.21
+采用的是拷贝的方法，+=返回自身引用，显然本题的方法没有性能上的优势，应该在+中使用+=的方法。
### 14.29
因为递增和递减会改变原对象的状态，const限制了不能修改其状态。
### 14.31
对于 StrBlobPtr 类，它的所有数据成员都能被合成的拷贝控制成员（synthesized copy-control members）恰当的拷贝、赋值和销毁。
### 14.33
0或多个
### 14.41
在 C++11 中，lambda 是通过匿名的函数对象来实现的，因此我们可以把 lambda 看作是对函数对象在使用方式上进行的简化。

当代码需要一个简单的函数，并且这个函数并不会在其他地方被使用时，就可以使用 lambda 来实现，此时它所起的作用类似于匿名函数。

但如果这个函数需要多次使用，并且它需要保存某些状态的话，使用**函数对象（functor）**则更合适一些。
### 14.45
如果要转换成 string，那么返回值应该是 bookNo；如果要转换成 double，那么返回值应该是 revenue。
### 14.46
Sales_data 类不应该定义这两种类型转换运算符，因为对于该类型来讲，它包含三个数据成员：bookNo，units_sold 和 revenue，只有三者在一起才是有效的数据。

但如果确实想要定义这两个类型转换运算符的话，应该把它们声明成 explicit 的，这样可以防止 Sales_data 在某些情况下被默认转换成 string 或 double 类型，这有可能导致意料之外的运算结果。
### 14.47
前者将对象转换成 const int ，在接受 const int 值的地方才能够使用。

后者则将对象转换成 int 值，且类型转换运算符不允许修改对象的内容。相对来说更加通用一些。
### 14.48
该运算符应该是explicit的，bool类型转换更多用作条件判断，而当条件判断时，显式的类型转换会被隐式的利用。
### 14.50
ex1失败，存在二义性

ex2执行LongDouble类到float的转换
### 14.51
这里会优先调用 void calc(int) 函数。因为 double 转换为 int 是标准类型转换，而转换成 LongDouble 则是转换为用户自定义类型，实际上是调用了转换构造函数，因此前者优先。
### 14.52
ld = si + ld; 存在歧义。
ld = ld + si 可以同时使用1和2，但1更精确。（在2中，SmallInt需要转换为double）
### 14.53
内置的 operator+(int, double) 是可行的；

而 3.14 可以转换为 int，然后再转换为 SmallInt，所以 SmallInt 的成员 operator+ 也是可行的。

两者都需要进行类型转换，所以会产生二义性。改为 double d = s1 + SmallInt(3.14); 即可。