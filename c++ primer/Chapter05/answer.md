### 5.1
空语句是最简单的语句，空语句由一个单独的分号构成。如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句，空语句什么也不做。

一种常见的情况是，当循环的全部工作在条件部分就可以完成时，我们通常会用到空语句。使用空语句时最好加上注释，从而令代码的阅读者知道这条语句是有意省略内容的。
### 5.2
块是指用花括号括起来的语句和声明的序列，也称为复合语句。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，此时应该使用块。块不需要以分号结束。

例如，循环体必须是一条语句，但是我们通常需要在循环体内做很多事情，此时就应该把多条语句用花括号括起来，从而把语句序列转换成块。
### 5.4
```c++
// (A)
auto iter = s.begin();
while(iter != s.end()){};
```
```c++
// (B)
bool status = 1;
while(status = find(word)){};
if(!status){};
```
### 5.7
（a）if 语句的循环体应该是一条语句，需要以分号结束，程序修改为：

（b）if 语句的循环体只能是一条语句，本题从代码的缩进格式上来说需要做两件事，一是修改 minval 的值，二是重置 occurs 的值，所以必须把这两条语句放在一个块里。

（c）ival 是定义在 if 语句中的变量，其作用域仅限于第一个 if 语句，要想在第二个 if 语句中也使用它，就必须把它定义在两个 if 语句的外部。

（d）程序的原意是判断 ival 的值是否是 0，原题使用赋值运算符的结果是把 0 赋给了 ival，然后检验 ival 的值，这样使得条件永远不会满足。
### 5.8
悬垂 else 是指程序中的 if 分支多于 else 分支时，如何为 else 寻找与之匹配的 if 分支的问题。

C++ 规定，else 与离它最近的尚未匹配的 if 匹配，从而消除了二义性。
### 5.13
（a）的错误是在每个 case 分支中都缺少了 break; 语句，造成的后果是一旦执行了前面的 case 分支，必定还会继续执行接下来的其他 case 分支。举例说明，如果 ch 的内容是字符 a ，则 aCnt、eCnt 和 iouCnt 的值都会增加；如果 ch 的内容是字符 e ，则 eCnt 和 iouCnt 的值都会增加，这显然与程序的预期是不相符的。

（b）的错误是在 case 分支中定义并初始化了变量 ix，同时在 default 分支中使用了该变量，此时如果控制流跳过 case 分支而直接到达 default 分支，则会试图使用未经初始化的变量，因而该程序无法通过编译。解决办法是，把 ix 的定义放在 switch 语句之前。

（c）的错误是在同一个 case 标签中放置了多个值，而 C++ 规定一个 case 标签只能对应一个值。

（d）的错误是使用变量作为 case 标签的内容，C++ 规定，case 标签的内容只能是整型常量表达式。
### 5.15
（a）的错误是在 for 语句中定义了变量 ix，然后试图在 for 语句之外继续使用 ix。因为 ix 定义在 for 语句的内部，所以其作用域仅限于 for 循环体。在 if 语句中 ix 已经失效，因此程序无法编译通过。

修改后的程序如下：
```c++
int ix;
for (ix = 0; ix != sz; ++ix) { /* ... */ }
if (ix != sz)
// ...
```
（b）的错误有两个，一是变量 ix 未经初始化就直接使用，二是 for 语句的控制结构缺少一句话，在语法上是错误的。

修改后的程序如下：
```c++
int ix;
for (ix = 0; ix != sz; ++ix) { /* ... */ }
```
（c）的错误是一旦进入循环，程序就会无休止地执行下去。也就是说，当初始情况下 ix != sz 时，由题意可知 ix 和 sz 一直同步增长，循环的终止条件永远不会满足，所以该循环是一个死循环。

修改后的程序如下：
```c++
for (int ix = 0; ix != sz; ++ix) { /* ... */ }
```
### 5.16
在大多数情况下，两种循环形式可以相互转换。如果只能使用一种循环，作者倾向于使用 for 循环。for 循环的优点是结构严谨，便于控制程序的逻辑。
### 5.18
（a）的含义是每次循环读入两个整数并输出它们的和。因为 do-while 语句的循环体必须是一条语句或者一个语句块，所以在本题中应该把循环体的内容用花括号括起来。修改后的程序是：
```c++
do 
{
  int v1, v2;
  cout << "Please enter two numbers to sum:";
  if (cin >> v1 >> v2)
    cout << "Sum is: " << v1 + v2 << endl;
} while (cin);
```
（b）的含义是当 get_response 的返回值不为 0 时执行循环体。因为出现在 do-while 语句条件部分的变量必须定义在循环体之外，所以该程序是错误的。修改后的程序是：
```c++
int ival;
do 
{
  ival = get_response();
} while (ival);
```
（c）的含义是当 get_response 的返回值不为 0 时执行循环体。因为出现在 do-while 语句条件部分的变量必须定义在循环体之外，所以该程序是错误的。修改后的程序是：
```c++
int ival;
do 
{
  ival = get_response();
} while (ival);
```
### 5.22
```c++
int sz;
do {
  sz = get_size();
} while (sz <= 0);
```
### 5.24
因为没有 catch 语句，所以系统只报告异常而并不处理它。