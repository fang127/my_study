### 9.1
（a）“按字典序插入到容器中”意味着进行插入排序操作，从而需要在容器内部频繁进行插入操作，vector 在尾部之外的位置插入和删除元素很慢，deque 在头尾之外的位置插入和删除元素很慢，而 list 在任何位置插入、删除速度都很快。因此，这个任务选择 list 更为合适。当然，如果不是必须边读取单词边插入到容器中，可以使用 vector，将读入的单词依次追加到尾部，读取完毕后，调用标准库到排序算法将单词重排为字典序。

（b）由于需要在头、尾分别进行插入、删除操作，因此将 vector 排除在外，deque 和 list 都可以达到很好的性能。如果还需要频繁进行随机访问，则 deque 更好。

（c）由于整数占用空间很小，且给数字排序时需要频繁随机访问元素，将 list 排除在外。由于无须在头部进行插入、删除操作，因此使用 vector 即可，无须使用 deque。
### 9.3
两个迭代器 begin 和 end 必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；而且，对 begin 反复进行递增操作，可保证到达 end，即 end 不在 begin 之前。
### 9.6
与 vector 和 deque 不同，list 的迭代器不支持 < 运算，只支持递增、递减、== 以及 != 运算。

原因在于这几种数据结构实现上的不同。vector 和 deque 将元素在内存中连续保存，而 list 则是将元素以链表方式存储，因此前者可以方便地实现迭代器的大小比较（类似指针的大小比较）来体现元素的前后关系。而在 list 中，两个指针的大小关系与它们指向的元素的前后关系并不一定是吻合的，实现 < 运算将会非常困难和低效。
### 9.7
使用迭代器类型 vector<int>::iterator 来索引 int 的 vector 中的元素。
### 9.8
为了读取 string 的 list 中的元素，应使用 list<string>::value_type ，因为 value_type 表示元素类型。

为了写入数据，需要（非常量）引用类型，因此应使用 list<string>::reference
### 9.9
cbegin 是 C++ 新标准引入的，用来与 auto 结合使用。它返回指向容器第一个元素的 const 迭代器，可以用来只读地访问容器元素，但不能对容器元素进行修改。因此，当不需要写访问时，应该使用 cbegin。

begin 则是被重载过的，有两个版本：其中一个是 const 成员函数，也返回 const 迭代器；另一个则返回普通迭代器，可以对容器元素进行修改。
### 9.10
1.  std::vector<int> // v1
2.  const std::vector<int> // v2
3.  std::vector<int>::iterator // it1
4.  std::vector<int>::const_iterator // it2
5.  std::vector<int>::const_iterator // it3
6.  std::vector<int>::const_iterator // it4
### 9.12 
接受一个已有容器的构造函数会拷贝此容器中的所有元素，这样，初始化完成后，我们得到此容器的一个一模一样的拷贝。当我们确实需要一个容器的完整拷贝时这种初始化方式非常方便。接受已有容器的构造函数会将已有容器中的所有元素拷贝到新容器中，因此新容器的大小与已有容器相同，且元素类型相同。

但当我们不需要已有容器中的全部元素，而只是想拷贝其中一部分元素时，可使用接受两个迭代器的构造函数。传递给它要拷贝的范围的起始和尾后位置的迭代器，即可令新容器对象包含所需范围中元素的拷贝。该方法容器类型可以不同，元素类型也可以不同，只要可以互相转换即可。
### 9.17
首先，容器类型必须相同，元素类型也必须相同。

其次，元素类型必须支持 < 运算符。
### 9.22
循环中未对 iter 进行递增操作，iter 无法向中点推进。其次，即使加入了 iter++ 语句，由于向 iv 插入元素后，iter 已经失效，iter++ 也不能起到将迭代器向前推进一个元素的作用。修改方法如下：

首先，将 insert 返回的迭代器赋予 iter，这样，iter 将指向新插入的元素 y。我们知道，insert 将 y 插入到 iter 原来指向的元素 x 之前的位置，因此，接下来我们需要进行两次 iter++ 才能将 iter 推进到 x 之后的位置。

其次，insert() 也会使 mid 失效，因此，只正确设置 iter 仍不能令循环在正确的时候结束，我们还需要设置 mid 使之指向 iv 原来的中央位置的元素。在未插入任何新元素之前，此位置是 iv.begin() + iv.size() / 2 ，我们将此时的 iv.size() 的值记录在变量 org_size 中。然后在循环过程中统计新插入的元素的个数 new_ele ，则在任何时候，iv.begin() + org_size / 2 + new_ele 都能正确指向 iv 原来的中央位置的元素。
```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> iv = {1, 1, 2, 1};          // int 的 vector
    int some_val = 1;

    vector<int>::iterator iter = iv.begin();
    int org_size = iv.size(), new_ele = 0;  // 原大小和新元素个数

    // 每个循环步都重新计算 mid，保证正确指向 iv 原中央位置的元素
    while (iter != (iv.begin() + org_size / 2 + new_ele))
        if (*iter == some_val) 
        {
            iter = iv.insert(iter, 2 * some_val);   // iter 指向新元素
            ++new_ele;
            iter += 2;                // 将 iter 推进到旧元素的下一个元素
        } 
        else 
        {
            ++iter;                         // 指向后推进一个位置
        }

    // 用 begin() 获取 vector 首元素迭代器，遍历 vector 中的所有元素
    for (iter = iv.begin(); iter != iv.end(); ++iter)
        cout << *iter << endl;

    return 0;
}
```
### 9.23
4 个变量的值会一样，都等于容器中唯一一个元素的值。
### 9.24
下面的程序会异常终止。因为 vector 为空，此时用 at 访问容器的第一个元素会抛出一个 out_of_range 异常，而此程序未捕获异常，因此程序会因异常退出。正确的编程方式是，捕获可能的 out_of_range 异常，进行相应的处理。

但对于后 3 种获取容器首元素的方法，当容器为空时，不会抛出 out_of_range 异常，而是导致程序直接退出（注释掉前几条语句即可看到后面语句的执行效果）。因此，正确的编程方式是，在采用这几种获取容器的方法时，检查下标的合法性（对 front 和 begin 只需检查容器是否为空），确定没有问题后再获取元素。当然这种方法对 at 也适用。
### 9.25
如果两个迭代器 elem1 和 elem2 相等，则什么也不会发生，容器保持不变。哪怕两个迭代器是指向尾后位置（例如 end() + 1），也是如此，程序也不会出错。

因此 elem1 和 elem2 都是尾后迭代器时，容器保持不变。

如果 elem2 为尾后迭代器，elem1 指向之前的合法位置，则会删除从 elem1 开始直至容器末尾的所有元素。
### 9.29
vec.resize(100); // 将 vec 的大小调整为 100,原有25个元素，后75个添加的元素为0；
vec.resize(10); // 将 vec 的大小调整为 10，vec 中只剩下前 10 个元素；
### 9.30
元素类型为内置类型，或者标准库容器，如果是自定义类类型，需要提供默认构造函数。
### 9.31
list 和 forward_list 与其他容器的一个不同是，迭代器不支持加减运算，究其原因，链表中元素并非在内存中连续存储，因此无法通过地址的加减在元素间远距离移动。因此，应多次调用 ++ 来实现与迭代器加法相同的效果。
### 9.32
很多编译器对实参求值、向形参传递的处理顺序是由右至左。这意味着，编译器在编译上述代码时，首先对 *iter++ 求值，传递给 insert 第二个形参，此时 iter 已指向当前奇数的下一个元素，因此传递给 insert 的第一个参数的迭代器指向的是错误的位置，程序执行会发生混乱，最终崩溃。

因此，若将代码改为 iter = vi.insert(iter++, *iter); ，或是使用由左至右求值、传递参数的编译器，代码的运行结果是正确的。当然，这样的代码在逻辑上是毫无道理的。
### 9.33
向 vector 中插入新元素后，原有迭代器都会失效。因此，不将 insert() 返回的迭代器赋予 begin，会使 begin 失效。继续使用 begin 会导致程序崩溃。对此程序，保存尾后迭代器和不向 begin 赋值两个错误存在其一，程序都会崩溃。
### 9.34
此段代码的第一个错误是忘记使用花括号，使得 ++iter 变成循环结束后的第一条语句，而非所期望的循环体的最后一条语句。因此，除非容器为空，否则程序会陷入死循环：

若容器的第一个元素是偶数，布尔表示式为假，if 语句真分支不会被执行，iter 保持不变（因为 iter 不在循环作用域内）。循环继续执行，真分支仍然不会执行，iter 继续保持不变，如此陷入死循环。

若容器的第一个元素是奇数，insert 语句被调用，将该值插入到首元素之前，并将返回的迭代器（指向新插入元素）赋予 iter，因此 iter 指向新首元素。继续执行循环，会继续将首元素复制到容器首位置，并令 iter 指向它，如此陷入死循环。
### 9.35
capacity 返回已经为 vector 分配了多大内存空间（单位是元素大小），也就是在不分配新空间的情况下，容器可以保存多少个元素。而 size 则返回容器当前已经保存了多少个元素。
### 9.36
由上一题解答可知，这是不可能的。
### 9.37
list 是链表，当有新元素加入时，会从内存空间中分配一个新节点保存它；当从链表中删除元素时，该节点占用的内存空间会被立即释放。因此，一个链表占用的内存空间总是与它当前保存的的元素所需的空间相等。

而 array 是固定大小数组，内存一次性分配，大小不变，不会变化。

因此，它们均不需要 capacity。
### 9.39
首先，reserve 为 svec 分配了 1024 个元素（字符串）的空间。

随后，循环会不断读入字符串，添加到 svec 末尾，直至遇到文件结束符。这个过程中，如果读入的字符串数量不多于 1024，则 svec 的容量（capacity）保持不变，不会分配新的内存空间。否则，会按一定规则分配更大的内存空间，并进行字符串的移动。

接下来，resize 将向 svec 末尾添加当前字符串数量一半那么多的新字符串，它们的值都是空串。若空间不够，会分配足够容纳这些新字符串的内存空间。
### 9.40
读入256，capacity()为1024；
读入512，capacity()为1024；
读入1000，capacity()为2048；
读入1048，capacity()为2048；
### 9.42
由于知道至少读取 100 个字符，因此可以用 reserve 先为 string 分配 100 个字符的空间，然后逐个读取字符，用 push_back 添加到 string 末尾。
### 9.43
s.find(args) 查找 s 中 args 第一次出现的位置，即第一个与 args 匹配的字符串的位置。args 是作为一个字符串整体在 s 中查找，而非一个字符集合在 s 中查找其中字符。因此，对 325 页给定的 name 和 numbers 值，在 numbers 中不存在与 name 匹配的字符串，find 会返回 npos。
