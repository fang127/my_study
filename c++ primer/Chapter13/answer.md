### 13.1
如果一个构造函数的第一个参数是它自身类类型的引用，且其他任何的额外参数都有默认值，则此函数为拷贝构造函数。

一般参数几乎是一个const自身类型的引用，其次通常不应该是explicit。

在以下这种情况会使用：
1. 调用函数实参传入给非引用的形参时
2. 从返回非引用的类型的函数返回一个对象
3. 花括号初始化一个数组中的元素或者一个聚合类的成员
4. stl容器调用如push_back,insert的函数时
### 13.2
该声明为拷贝构造函数，但是形参不是引用，会造成无限递归调用拷贝构造函数的情况，无法完成拷贝
### 13.3
当我们复制 StrBlob 时，shared_ptr 成员的 use_count 添加一个。

复制 StrBlobPrts 时，weak_ptr 成员的 use_count 不会更改。（因为计数属于 shared_ptr）
### 13.4
1. 调用该函数时，形参拷贝实参
2. local拷贝arg
3. 在堆区创建Point时，会拷贝global
4. 将local拷贝给*heap
5. 初始化列表初始化pa[4]时，传入的local和*heap都会被拷贝一次
6. 返回*heap，返回不是引用类型，会调用拷贝构造函数
### 13.6
拷贝赋值运算符是一个名为operator=的函数，它接受一个与该类相同类型的参数。

当发生赋值操作时，会使用该运算符。  

合成的拷贝赋值运算符会使用成员类型的拷贝赋值运算符，将右侧对象的每个非静态成员赋值给左侧对象的对应成员。  

当类未定义自己的拷贝赋值运算符时，编译器会合成一个。
### 13.7
在这两种情况下，都会发生浅拷贝。所有指针都指向同一个地址。

当我们复制 StrBlob 时，shared_ptr 成员的 use_count 添加一个。

复制 StrBlobPrts 时，weak_ptr 成员的 use_count 不会更改。（因为计数属于 shared_ptr）
### 13.9
析构函数是一个类的成员函数，名字由波浪线和类名构成，没有返回值，也不接受参数。

析构函数完成类中成员的销毁。

没有定义析构函数时编译器自己生成一个合成的析构函数
### 13.10
当一个StrBlob对象被销毁时，动态对象的使用计数会减少。如果没有指向该动态对象的shared_ptr，它将被释放。  

当一个StrBlobPter对象被销毁时，动态分配的对象不会被释放。
### 13.12
3次，accum，item1，item2都会调用
### 13.14
3个相同的内容。
### 13.15
输出将是三个不同的内容。
### 13.16
是的，输出结果会改变。因为在函数f内部没有发生复制操作，所以三个输出结果相同。
### 13.19
当用 a 初始化 b 时，会调用拷贝构造函数。如果不定义拷贝构造函数，则合成的拷贝构造函数简单复制 id，会使两者的序号相同。

当用 b 为 c 赋值时，会调用拷贝赋值运算符。如果不定义自己的版本，则编译器定义的合成版本会简单复制 id，会使两者的序号相同。
### 13.20
两个类都未定义拷贝控制成员，因此都是编译器为它们定义合成版本。
### 13.21
由于两个类的成员都有很好的拷贝控制成员，因此合成的版本会依次调用成员的对应的合成控制成员，因此合成版本满足此案例的所有要求，因此无需定义自定义版本控制成员。
### 13.24
如果为定义析构函数，则无法释放堆区中的string，如果未定义拷贝构造函数，则使用合成的拷贝构造函数，ps将会是浅拷贝。
### 13.25
拷贝构造函数需要将shared_ptr中的内容拷贝一份自己的，而不是共享，拷贝赋值运算符需要释放自己shared_ptr中保存的内容，然后将右侧对象指针中的内容拷贝一份属于自己的，而不是共享。不需要析构函数是因为该类使用的是智能指针管理堆区内存，不需要手动释放。
### 13.29
在此 swap 函数中又调用了 swap 来交换 HasPtr 成员 ps 和 i。但这两个成员的类型分别是指针和整型，都是内置类型，因此函数中的 swap 调用被解析为 std::swap，而不是 HasPtr 的特定版本 swap（也就是自身），所以不会导致递归循环。
### 13.32
默认 swap 版本（std::swap）简单交换两个对象（内置类型的对象）的非静态成员，对 HasPtr 而言，就是交换 string 指针 ps、引用计数指针 use 和整型值 i。可以看出，这种语义是符合期望的 —— 两个 HasPtr 指向了原来对方的 string，而两者互换 string 后，各自的引用计数本应该是不变的（都是减 1 再加 1）。因此，默认 swap 版本已经能正确处理类指针 HasPtr 的交换，专用 swap 版本（用户自定义的 swap）不会带来更多收益。
### 13.33
因为folders是一个set，元素为folder *，是个指针，如果传入的是folder，则是值传递，insert的是一个拷贝的folder的的地址，而不是实参的地址，在函数结束后，形参会被销毁，造成野指针。如果是const folder &，则无法修改folder对象，无法调用addmsg和remmsg，无法添加或者删除message。
### 13.35
Message 类包含两个数据成员：content 为 string 类型，folders 为 set。这两个标准库类都有完备的拷贝控制成员，因此 Message 使用合成的拷贝控制成员的话，简单拷贝这两个成员也能实现正确拷贝。

但是，本问题的需求不仅如此。

当拷贝 Message 时，不仅要拷贝这个 Message 在哪些 Folder 中，还要将 Message 加到每个 Folder 中 —— 调用 addMsg。

类似的，当销毁 Message 时，需要将它从所有 Folder 中删除 —— 调用 remMsg。

因此，不能依赖合成的拷贝控制成员，必须设计自己的版本来完成这些薄记工作。
### 13.38
如果采用拷贝并交换方式，执行过程是这样：

由于赋值运算符的参数是 Message 类型，因此会将实参拷贝给形参 rhs，这会触发拷贝构造函数，将实参的 contents 和 folders 拷贝给 rhs，并调用 add_to_Folders 将 rhs 添加到 folders 的所有文件夹中。
随后赋值运算符调用 swap 交换 *this 和 rhs，首先遍历两者的 folders，将它们从自己的文件夹中删除；然后调用 string 和 set 的 swap 交换它们的 contents 和 folders；最后，再遍历两者新的 folders，将它们分别添加到自己的新文件夹中。
最后，赋值运算符结束，rhs 被销毁，析构函数调用 remove_from_Folders 将 rhs 从自己的所有文件夹中删除。
显然，语义是正确的，达到了预期目的。但效率低下，rhs 创建、销毁并两次添加、删除是无意义的。而采用拷贝赋值运算符的标准编写方式，形参 rhs 为引用类型，就能避免这些冗余操作，具有更好的性能。
### 13.41
first_free已经指向已有元素末尾位置的下一位置了，如果使用前置递增，则先递增，再构造，中间会空一个string的空间没有构造。
### 13.43
for_each更好，遍历销毁每一个string，更加直观
### 13.45
所谓右值引用就是必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

左值引用，也就是 “常规引用”，不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。

返回左值的表达式包括：返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符；返回右值的包括：返回非引用类型的函数及算数、关系、位和后置递增/递减运算符。可以看到，左值的特点是有持久的状态，而右值则是短暂的。
### 13.46
r1右值引用

r2左值引用

r3左值引用

r4右值引用
### 13.51
unique_ptr 不能拷贝，但有一个例外 —— 将要被销毁的 unique_ptr 是可以拷贝或赋值的。因此，在 418 页的 clone 函数中返回局部 unique_ptr 对象 ret 是可以的，因为 ret 马上就要被销毁了。而此时 “拷贝” 其实是触发移动构造函数进行了移动。
### 13.52
对 hp = hp2，因为 hp2 是一个变量，变量是一个左值，因此它传递给赋值运算符参数 rhs 的过程是拷贝构造过程，rhs 获得 h2 的一个副本，rhs.ps 与 h2.ps 指向不同的 string，但两个 string 包含相同的内容。在赋值运算符中，交换 hp 和 rhs，rhs 指向 hp 原来的 string，在赋值结束后 rhs 被销毁。最终结果，hp 和 hp2 指向两个独立的 string，但内容相同。

对 hp = std::move(hp2)，hp2 传递给赋值运算符参数 rhs 的过程是移动构造过程，rhs.ps 指向 hp2.ps 原来的 string，hp2 的 ps 被设置为空指针。然后在赋值运算符中，交换 hp 和 rhs，rhs 指向 hp 原来的 string，在赋值结束后 rhs 被销毁。最终结果，hp 指向 hp2 原来的 string，而 hp2 则变为空。减少一次拷贝。
### 13.53
在进行拷贝赋值时，先通过拷贝构造创建了 hp2 的拷贝 rhs，然后再交换 hp 和 rhs，rhs 作为一个中间媒介，只是起到将值从 hp2 传递给 hp 的作用，是一个冗余的操作。

类似的，在进行移动赋值时，先从 hp2 转移到 rhs，在交换到 hp，也是冗余的。

也就是说，这种实现方式唯一的用处是统一了拷贝赋值运算和移动赋值运算，但在性能角度，多了一次从 rhs 的间接传递，性能不好。
### 13.54
会产生编译错误。

因为对于 h2 = std::move(h3); 这样的赋值语句来说，两个运算符匹配的一样好，从而产生了二义性。
### 13.56
首先，局部变量 ret 拷贝了被调用对象的一个副本。然后，对 ret 调用 sorted，由于并非是函数返回语句或函数结束（虽然写成一条语句，但执行过程是先调用 sorted，然后将结果返回），因此编译器认为它是左值，仍然调用左值引用版本，产生递归循环。
### 13.57
与上一题不同，本题的写法可以正确利用右值引用版本来完成排序。原因在于，编译器认为 Foo(*this) 是一个 “无主” 的右值，对它调用 sorted 会匹配右值引用版本。