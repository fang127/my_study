### 11.1
​**vector: 像动态数组**。元素存储在单个连续的、按顺序分配的内存块中。元素的位置​（索引）完全由插入顺序决定（除非你显式排序或插入到中间）。

​**map: 像一个字典或关联数组**。它存储的是键值对 (std::pair<const Key, Value>)​。元素并不是按插入顺序存储，而是始终按键（Key）的升序排列（默认情况下，可通过比较器自定义）。内部使用自平衡二叉搜索树（通常是红黑树）来实现高效的查找和排序。std::unordered_map 使用哈希表实现，不保证顺序。

​**vector: 通过索引（整数位置）​**​ 访问元素，使用 operator[] (如 vec[5]) 或 at() (边界检查)。提供高效的 O(1) 随机访问。

​**map: 通过键（Key）​​ 访问对应的值（Value）​**，使用 operator[] (如 myMap["Alice"]) 或 at() (边界检查)，或者使用 find() 获得指向键值对迭代器。​不支持通过整数索引随机访问元素。​​

​**vector**: 没有“键”的概念。所有元素都有一个位置索引，但不同元素可以有完全相同的值 (value)。索引本身就是唯一的标识符（位置）。

​**map: 要求键（Key）必须唯一**。如果你尝试插入一个键已经存在的键值对，新插入的值通常不会替换旧值（insert 操作），或者会替换旧值（operator[] 赋值）。std::multimap 允许重复键。

​**vector**:
在末尾添加或删除元素 (push_back, pop_back) 非常高效，​**平摊 O(1)**​ 时间复杂度。
在中间或开头插入或删除元素 (insert, erase) 可能很低效 (O(n))，因为需要移动后面的元素。
​查找特定值需要遍历数组，最坏情况下需要检查每个元素 (O(n))，除非数据已排序 (然后可用 std::binary_search，但也需 O(log n) 前提是排序)。

​**map**:
​插入、查找 (find)、删除 (erase) 一个特定键的操作时间复杂度都是 O(log n)，这得益于其内部平衡二叉搜索树的结构。即使数据量很大，查找也非常快。
std::unordered_map 平均情况下插入和查找是 O(1)（取决于哈希函数和冲突解决），最坏情况 O(n)。

​**vector: ​元素在内存中连续存储**。这带来了非常好的缓存局部性​（访问一个元素后，访问附近元素的概率很高且速度快），也是高效随机访问 (O(1)) 的基础。

​**map: 元素（节点）分散在堆内存中，每个节点包含键、值以及指向子节点的指针。​内存不是连续的**，可能导致较差的缓存局部性（访问一个节点后不一定能高效访问“物理上”相邻的节点）。

​**vector**: 对 vector 的很多修改操作（如在中间插入/删除元素，或可能导致重新分配内存的操作 push_back）会使指向该 vector 的所有迭代器、指针和引用失效。

​**map: 迭代器的失效规则更友好。​删除元素只会使指向被删除元素的迭代器失效，其它迭代器仍然有效。​插入操作**永远不会使现有迭代器失效（除非容量耗尽导致重新分配，但树结构通常不是整体重分配）。这是因为元素是以独立节点形式存在的。

### 11.2
大部分情况下只在末尾添加或删除，需要频繁访问任意位置的元素，则 vector 可带来最高的效率。

若需要频繁在头部和尾部添加或删除元素，则 deque 是最后的选择。

如果元素较大（如大的类对象），数量预先不知道，或是程序运行过程中频繁变化，对元素的访问更多是顺序访问全部或很多元素，则 list 很合适。

map 很适合对一些对象按它们的某个特征进行访问的情形。典型的例如按学生的姓名来查询学生信息，即可将学生姓名作为关键字，将学生信息作为元素值，保存在 map 中。再比如统计单词出现的次数。

set，顾名思义，就是集合类型。当需要保存特定的值集合 —— 通常是满足/不满足某种要求的值集合，用 set 最为方便。比如黑名单。
### 11.5
 map，其中保存的是 <关键字, 值> 对，按关键字访问值。 set，它是简单的值的集合。
### 11.6
set是简单的值的集合，可以快速查找元素，如果需要判定元素是否为给定的值，则用set。   
list支持顺序访问，中间插入值很方便，而已可以重复保存，这这些场景下用list。
### 11.8
vector 是无序线性表，find 查找指定值只能采用顺序查找方式，所花费的时间与 vector.size() 呈线性关系。而 set 是用红黑树实现的，花费的时间与 vector.size() 呈对数关系。当单词数量已经非常多时，set 的性能优势是巨大的。
### 11.10
由于有序容器要求关键字类型必须支持比较操作 <，因此

map<vector<int>::iterator, int> m1;
是可以的，因为 vector 的迭代器支持比较操作。而

map<list<int>::iterator, int> m2;
则不行，因为 list 的元素不是连续存储，其迭代器不支持比较操作。
### 11.15
1. mapped_type 是 vector<int>；

1. key_type 是 int；

3. value_type 是 pair<const int, vector<int>>。
### 11.17
1. 合法
2. 不合法，multiset没有push_back()
3. 合法
4. 合法
### 11.18
```c++
map<const string, size_t>::iterator
```
### 11.19
```c++
std::map<Sales_data,bool(*)(Sales_data &,Sales_data &)>::iterator
```
### 11.21
输入一个word，并将其输入到word_count中，值为0，无论关键字存在或者不存在，都对value进行递增操作。
### 11.22
```c++
std::pair<std::string,std::vector<int>> // 参数类型 
std::pair<std::map<std::string,std::vector<int>>::iterator,bool> // 返回类型
```
### 11.24
向map添加了一个新元素，关键字为0，值为1
### 11.25
错误，vector中没有元素，不可以通过下标访问或者添加，只能通过insert，push_back，emplace的方式添加
### 11.26
```c++
std::map<std::string,int> m;
// 下标操作用关键字类型，即string，返回类型为int
```
### 11.27
find 查找关键字在容器中出现的位置，而 count 则还会统计关键字出现的次数。

因此，当我们希望知道（允许重复关键字的）容器中有多少元素的关键字与给定关键字相同时，使用 count。

当我们只关心关键字是否在容器中时，使用 find 就足够了。特别是，对于不允许重复关键字的关联容器，find 和 count 的效果没有什么区别，使用 find 就可以了。或者，当我们需要获取具有给定关键字的元素（而不只是统计个数）时，也需要使用 find。

find 和下标操作有一个重要区别，当给定关键字不在容器中时，下标操作会插入一个具有该关键字的元素。因此，当我们想检查给定关键字是否存在时，应该用 find 而不是下标操作。
### 11.28
```c++
// map 类型
map<string, vector<int>> m;
// 保存 find 返回结果的变量
map<string, vector<int>>::iterator iter;
```
### 11.29
对于不在容器中的key

upper_bound返回一个安全插入点，lower_bound返回一个安全插入点，不影响其他元素，equal_range返回一个pair，pair的元素为元素可以插入的安全点
### 11.30
pos.first为搜索到的第一个关键字的元素的位置的迭代器，pos.first->second表示解引用该迭代器后获得map的pair成员中的second值，即map的value。
### 11.34
若给定关键字 s 不在 m 中，下标运算符会试图构建新 pair 插入到 m 中，但由于 m 被限定为 const，如无法插入，程序报错。而且构建新的 pair 的到 m 中，也不符合我们的预期。
### 11.35
当 map 中没有给定关键字时，insert 操作与下标操作+赋值操作的效果类似，都是将关键字和值的 pair 添加到 map 中。

但当 map 中已有给定关键字，也就是新的转换规则与一条已有规则要转换同一个单词（关键字）时，两者的行为是不同的。下标操作会获得具有该关键字的元素（也就是已有规则）的值，并将新读入的值赋予它，也就是用新读入的规则覆盖了容器中的已有规则。但 insert 操作遇到关键字已存在的情况，则不会改变容器内容，而是返回一个值指出插入失败。因此，当规则文件（map_file）中存在多条规则转换相同单词时，下标+赋值的版本最终会用最后一条规则进行文本转换，而 insert 版本则会用第一条规则进行文本转换。
### 11.36
会乱掉，会用下一行整行作为value
### 11.37
无须版本通常性能更好，使用也更为简单。有序版本的优势是维护了关键字的序。

当元素的关键字类型没有明显的序的关系，或是维护元素的代价非常高时，无序容器非常有用。

但当应用要求必须维护元素的序时，有序版本就是唯一的选择。