### 6.1
形参出现在函数定义的地方，形参列表可以包含 0 个、1 个或多个形参，多个形参之间以逗号分隔。形参规定了一个函数所接受数据的类型和数量。

实参出现在函数调用的地方，实参的数量与形参一样多。实参的主要作用是初始化形参，并且这种初始化过程是一一对应的，即第一个实参初始化第一个形参、第二个实参初始化第二个形参，以此类推。实参的类型必须与对应的形参类型匹配。
### 6.2
(a) 返回值类型改为string
(b) void f2(int i){}
(c) int calc(int v1,int v2){return v1 + v2}
(d) double square(double x){return x * x}
### 6.6
形参和定义在函数体内部的变量统称为局部变量，它们对函数而言是局部的，仅在函数的作用域内可见。函数体内的局部变量又分为普通局部变量和静态局部变量，对于形参和普通局部变量来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。这几个概念的区别是：

形参是一种自动对象，函数开始时为形参申请内存空间，我们用调用函数时提供的实参初始化形参对应的自动对象。
普通变量对应的自动对象也容易理解，我们在定义该变量的语句处创建自动对象，如果定义语句提供了初始值，则用该值初始化；否则，执行默认初始化。当该变量所在的块结束后，变量失效。
局部静态变量比较特殊，它的生命周期贯穿函数调用及之后的时间。局部静态变量对应的对象称为局部静态对象，它的生命周期从定义语句处开始，直到程序结束才终止。
### 6.13
void f(T) 的形参采用的是传值方式，也就是说，实参的值被拷贝给形参，形参和实参是两个相互独立的变量，在函数 f 内部对形参所做的任何改动都不会影响实参的值。

void f(&T) 的形参采用的是传引用方式，此时形参是对应的实参的别名，形参绑定到初始化它的对象。如果我们改变了形参的值，也就是改变了对应实参的值。
### 6.14
io流作为形参传递应该为引用传递，实参为数组时，形参不可以为引用
### 6.15
find_char 函数的三个参数的类型设定与该函数的处理逻辑密切相关，原因分别如下：

对于待查找的字符串 s 来说，为了避免拷贝长字符串，使用引用类型；同时我们只执行查找操作，无须改变字符串的内容，所以将其声明为常量引用。
对于待查找的字符 c 来说，它的类型是 char，只占 1 字节，拷贝的代价很低，而且我们无须操作实参在内存中实际存储的内容，只把它的值拷贝给形参即可，所以不需要使用引用类型。
对于字符出现的次数 occurs 来说，因为需要把函数内对实参值的更改反映在函数外部，所以必须将其定义成引用类型；但是不能把它定义成常量引用，否则就不能改变所引的内容了。

如果s是普通引用会编译错误，不可用字符串字面值作为实参调用该函数;这会影响实参；如果occurs为常量引用，那么编译错误，常量不能作为左值；
### 6.16
本题的程序把参数类型设为非常量引用，这样做有几个缺陷：一是容易给使用者一种误导，即程序允许修改变量 s 的内容；二是限制了该函数所能接受的参数类型，我们无法把 const 对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。
### 6.18
```c++
bool compare(const matrix &,const matrix &);

std::vector<int> change_val(int,vector<int>::iterator);
```
### 6.19
(a) false 实参数量大于形参列表
(b) true
(c) true
(d) true
### 6.20
当函数对参数所做的操作不同时，应该选择适当的参数类型。如果需要修改参数的内容，则将其设置为普通引用类型；否则，如果不需要对参数内容做任何更改，最好设为常量引用类型。

就像前面几个练习题展示的那样，如果把一个本来应该是常量引用的形参设成了普通引用类型，有可能遇到几个问题：一是容易给使用者一种误导，即程序允许修改实参的内容；二是限制了该函数所能接受的实参类型，无法把 const 对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。
### 6.24
有之前的分析可知，print 函数的参数实际上等同于一个常量整型指针 const int * ，形参 ia 的维度 10 只是我们期望的数组维度，实际上不一定。即使实参数组的真实维度不是 10，也可以正常调用 print 函数。

上述 print 函数的定义存在一个潜在的风险，即虽然我们期望传入的数组维度是 10，但实际上任意维度的数组都可以传入。如果传入的数组维度较大，print 函数输出数组的前 10 个元素，不至于引发错误；相反，如果传入的数组维度不足 10，则 print 函数将强行输出一些未定义的值。
```c++
void print(const int ia[], const int sz) 
{
  for (size_t i = 0; i != sz; ++i)
    std::cout << ia[i] << std::endl;
}
```
### 6.28
initializer_list<string> 的所有元素类型都是 string，因此 const auto &elem : il 推断得到的 elem 的类型是 const string & 。使用引用是为了避免拷贝长字符串，把它定义为常量的原因是我们只需读取字符串的内容，不需要修改它（另外， initializer_list 列表中的元素原本属性就是 const，想修改也无法修改）。
### 6.29
引用类型的优势主要是可以直接操作引用的对象以及避免拷贝较为复杂的类型对象和容器对象。因为 initializer_list 对象的元素永远是常量值，所以我们不可能通过设定引用类型来更改循环控制变量的内容。只有当 initializer_list 对象的元素类型是类类型或容器类型（比如 string）时，才有必要把范围 for 循环的循环控制变量设为引用类型。
### 6.30
该函数在我的编译环境中无法编译通过，编译器发现了一个严重错误，即 for 循环中的 return 语句是非法的。函数的返回值类型是布尔值，而该条 return 语句没有返回任何值。

事实上程序还存在另一个严重错误，按照程序的逻辑，for 循环有可能不会中途退出而是一直执行完毕，此时显然缺少一条 return 语句处理这种情况。遗憾的是，编译器无法发现这一错误。
### 6.31
如果引用所引的是函数开始之前就已经存在的对象，则返回该引用是有效的；如果引用所引的是函数的局部变量，则随着函数结束局部变量也失效了，此时返回的引用无效。

当不希望返回的对象被修改时，返回对常量的引用。
### 6.32
该函数是合法的。get 函数接受一个整型指针，该指针实际指向一个整型数组的首元素，另外还接受一个整数表示数组中某个元素的索引值。它的返回值类型是整型引用，引用的对象是 array 数组的某个元素。当 get 函数执行完毕后，调用者得到实参数组 array 中索引为 index 的元素的引用。

在 main 函数中，首先创建一个包含 10 个整数的数组，名字是 ia。请注意，由于 ia 定义在 main 函数的内部，所以 ia 不会执行默认初始化操作，如果此时我们直接输出 ia 每个元素的值，则这些值都是未定义的。接下来进入循环，每次循环使用 get 函数得到数组 ia 中第 i 个元素的引用，为该引用赋值 i，也就是说，为第 i 个元素赋值 i 。循环结束时，ia 的元素依次被赋值为 0～9。
### 6.34
因为原文中递归函数的参数类型是 int，所以理论上用户传入 factorial 函数的参数可以是负数。按照原程序的逻辑，参数为负数时函数的返回值是 1.

如果修改递归函数的停止条件，则当参数的值为负时，会依次递归下去，执行连续乘法操作直至溢出。因此，不能把 if 语句的条件改成上述形式。
### 6.35
val--会先传递原值，再自减，这样递归时val不会减少，导致无限递归。应改为val - 1。
### 6.36
```c++
std::string (&func())[10];
```
### 6.37
```c++
// 类型别名
typedef std::string Arr[10]
Arr &func();
// 尾置
auto func()->std::string (&)[10];
// decltype
std::string str[10];
decltype(str) &func();
```
### 6.38
```c++
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
// 返回一个引用，该引用所引的对象是一个含有 5 个整数的数组。
decltype(odd) &arrPtr(int i)
{
    return (i % 2) ? odd : even; // 返回数组的引用。
}
```
### 6.39
（a）的第二个声明是非法的。它的意图是声明另外一个函数，该函数只接受整型常量作为实参，但是因为顶层 const 不影响传入函数的对象，所以一个拥有顶层 const 的形参无法与另一个没有顶层 const 的形参区分开来。

（b）的第二个声明是非法的。它的意图是通过函数的返回值区分两个同名的函数，但是这不可行，因为 C++ 规定重载函数必须在形参数量或形参类型上有所区别。如果两个同名函数的形参数量和类型都一样，那么即使返回类型不同也不行。

（c）的两个函数是重载关系，它们的形参类型有区别。
### 6.40
在上面的两个声明中，（a）是正确的而（b）是错误的。它们都用到了默认实参，但是 C++ 规定一旦某个形参被赋予了默认实参，则它后面的所有形参都必须有默认实参。

这一规定是为了防范可能出现的二义性，显然（b）违反了这一规定。
### 6.41
（a）是非法的，该函数有两个默认实参，但是总计有三个形参，其中第一个形参并未设定默认实参，所以要想调用该函数，至少需要提供一个实参。

（b）是合法的，本次调用提供了两个实参，第一个实参对应第一个形参 ht，第二个实参对应第二个形参 wd，其中 wd 的默认实参没有用到，第三个形参 bckgrnd 使用它的默认实参。

（c）在语法上是合法的，但是与程序的原意不符。从语法上来说，第一个实参对应第一个形参 ht，第二个实参的类型虽然是 char，但是它可以自动转换为第二个形参 wd 所需的 int 类型，所以编译时可以通过，但这显然违背了程序的原意，正常情况下，字符 * 应该被用来构成背景。
### 6.43
（a）应该放在头文件中。因为内联函数的定义对编译器而言必须是可见的，以便编译器能够在调用点内联展开该函数的代码，所以仅有函数的原型不够。并且，与一般的函数不同，内联函数有可能在程序中定义不止一次，此时必须保证在所有源文件中定义完全相同，把内联函数的定义放在头文件中可以确保这一点。

（b）是函数声明，应该放在头文件中。
### 6.44
```c++
inline bool isShorter(const string &s1, const string &s2) 
{
    return s1.size() < s2.size();
}
```
### 6.45

### 6.46
constexpr 要求所有参数和操作在编译期都能确定，而 std::string 的长度只有在运行时才能确定，std::string::size() 不是 constexpr，所以不能用于 constexpr 函数。
### 6.48
该程序对 assert 的使用有不合理之处。在调试器打开的情况下，当用户输入字符串 s 并且 s 的内容与 sought 不相等时，执行循环体，否则继续执行 assert(cin); 语句。换句话说，程序执行到 assert 的原因可能有两个，一是用户终止了输入，二是用户输入的内容正好与 sought 的内容一样。如果用户尝试终止输入（事实上用户总有停止输入结束程序的时候），则 assert 的条件为假，输出错误信息，这与程序的原意是不相符的。

当调试器关闭时，assert 什么也不做。
### 6.49
当程序中存在多个同名的重载函数时，编译器需要判断调用的是其中哪个函数，这时就有了候选函数和可行函数两个概念。

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数。候选函数具备两个典型特征：一是与被调用的函数同名；二是其声明在调用点可见。

函数匹配的第二步是考查本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等；二是每个实参的类型与对应的形参类型相同或者能转换成形参的类型。
### 6.50
f(2.56, 42) 的可行函数是 void f(int, int) 和 void f(double, double = 3.14)。但是最佳匹配不存在，因为这两个可行函数各有所长。对于这次调用来说，如果只考虑第一个实参 2.56，我们发现，void f(double, double = 3.14) 能够精确匹配，但是要匹配第二个参数，int 类型的实参 42 必须转换成 double 类型。如果考虑第二个实参 42，我们发现，void f(int, int) 能够精确匹配，但是要想调用 void f(int, int) 就必须把第一个 double 类型的实参 2.56 转换成 int 类型。最终的结果是这两个可行函数各自在一个实参上实现了更好的匹配，但是把它们比较起来无从判断孰优孰劣，因此编译器将因为这个调用具有二义性而拒绝其请求。

f(42) 的可行函数是 void f(int) 和 void f(double, double = 3.14)，其中最佳匹配是 void f(int)，因为参数无须做任何类型转换。

f(42, 0) 的可行函数是 void f(int, int) 和 void f(double, double = 3.14)，其中最佳匹配是 void f(int, int)，因为参数无须做任何类型转换。

f(2.56, 3.14) 的可行函数是 void f(int, int) 和 void f(double, double = 3.14)，其中最佳匹配是 void f(double, double = 3.14)，因为参数无须做任何类型转换。
### 6.52
(a) 整型提示
(b) 算术类型转换
### 6.53
（a）是合法的，两个函数的区别是它们的引用类型的形参是否引用了常量，属于底层 const，可以把两个函数区分开来。

（b）是合法的，两个函数的区别是它们的指针类型的形参是否指向了常量，属于底层 const，可以把两个函数区分开来。

（c）是非法的，两个函数的区别是它们的指针类型的形参本身是否是常量，属于顶层 const，根据本节介绍的匹配规则可知，向实参添加顶层 const 或者从实参中删除顶层 const 属于精确匹配，无法区分两个函数。
### 6.54
```c++
int func(int ,int);
std::vector<int (*)(int,int)>
```
### 6.55
