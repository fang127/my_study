### 4.1
105
### 4.2
```c++
*(vec.begin())  
(*(vec.begin())) + 1
```
### 4.3
正如题目所说，C++只规定了非常少的二元运算符（逻辑与运算符、逻辑或运算符、逗号运算符）的求值顺序，其他绝大多数二元运算符的求值顺序并没有明确规定。这样做提高了代码的生成效率，但是可能引发潜在的缺陷。

关键是缺陷的风险有多大？我们知道，对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为；而如果运算对象彼此无关，它们既不会改变同一对象的状态也不执行 IO 任务，则函数的调用顺序不受限制。

就作者的观点而言，这样的做法在一定程度上是可以接受的，前提是在编写程序时注意以下两点：

拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求；  
一旦改变了某个运算对象的值，在表达式的其它地方就不要再使用这个运算对象了。
### 4.4
91
### 4.5
-6 -18 0  -2
### 4.6
```c++
x % 2 == 0; // 为真时 num 是偶数，该表达式为假时 num 是奇数。
```
### 4.7
溢出是一种常见的算术运算错误。因为在计算机中存储某种类型的内存空间有限，所以该类型的表示能力（范围）也是有限的，当计算的结果值超出这个范围时，就会产生未定义的数值，这种错误称为溢出。
### 4.8
对于逻辑与运算符来说，当且仅当两个运算对象都为真时结果为真；对于逻辑或运算符来说，只要两个运算对象中的一个为真结果就为真。

逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略就是短路求值。其策略是：对于逻辑与运算符来说，当且仅当左侧运算对象为真时才计算右侧运算对象；对于逻辑或运算符来说，当且仅当左侧运算对象为假时才计算右侧运算对象。

值得注意的是，逻辑与运算符和逻辑或运算符是 C++ 中仅有的几个规定了求值顺序的运算符。相等性运算符的两个运算对象都需要求值，C++ 没有规定其求值顺序。
### 4.9
cp 是指向字符串的指针，因此上式的条件部分含义是首先检查指针 cp 是否有效。如果 cp 为空指针或无效指针，则条件不满足。如果 cp 有效，即 cp 指向了内存中的某个有效地址，继续解引用指针 cp 并检查 cp 所指对象是否为空字符 \0 ，如果 cp 所指的对象不是空字符则条件满足；否则不满足。
### 4.10
```c++
int i = 0;
while(std::cin >> i && i != 42)
{};
```
### 4.11
```c++
a > b && b > c && c > d
```
### 4.12
C++ 规定 <、<=、>、>= 的优先级高于 == 和 !=，因此上式的求值过程等同于 i != (j < k) ，意即先比较 j 和 k 的大小，得到的结果是一个布尔值（1 或 0）；然后判断 i 的值与之是否相等。
### 4.13
a.i=3,d=3

b.d=3.5,i=3
### 4.14
```c++
if(42=i){} // 报错，赋值运算符左侧必须是一个非常量左值
if(i=42){} // 正确，将42赋值给i，并且作为条件判断，永远为true,应该改成i == 42或者i != 42
```
### 4.15
该赋值语句是非法的，虽然连续赋值的形式本身并没有错，但是参与赋值的几个变量类型不同。其中，dval 是双精度浮点数，ival 是整数，pi 是整型指针。

自右向左分析赋值操作的含义，pi = 0 表示 pi 是一个空指针，接下来 ival = pi 试图把整型指针的值赋给整数，这是不符合语法规范的操作，无法编译通过。稍作调整，就可以把上述程序改为合法。
```c++
double dval;
int ival, *pi;
dval = ival = 0;
pi = 0;
```
### 4.16
```c++
if((p = getPtr()) != 0) // a
if(i != 1024 || i == 1024) // b
```
### 4.17
递增和递减运算符有两种形式：前置版本和后置版本。前置版本首先将运算对象加 1（或减 1），然后把改变后的对象作为求值结果。后置版本也将运算对象加 1（或减 1），但是求值结果是运算对象改变之前那个值的副本。这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。

我们的建议是，除非必须，否则不用递增（递减）运算符的后置版本。前置版本的递增运算符避免了不必要的工作，它把值加 1 后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便返回这个未修改的内容。如果我们不需要修改之前的值，那么后置版本的操作就是一种浪费。

对于整数和指针类型来说，编译器可能对这种额外的工作进行了一定的优化，但是对于相对复杂的迭代器类型来说，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能问题，而且更重要的是写出的代码会更符合编程人员的初衷。
### 4.18
如果这样做了，会产生两个错误结果：一是无法输出 vector 对象的第一个元素；二是当所有元素都不为负时，移动到最后一个元素的地方，程序试图继续向前移动迭代器并解引用一个根本不存在的元素。
### 4.19
（a）的含义是先判断指针 ptr 是否为空，如果不为空，继续判断指针 ptr 所指的整数是否为非 0 数。如果非 0，则该表达式的最终求值结果为真；否则为假。最后把指针 ptr 向后移动一位。该表达式从语法上分析是合法的，但是最后的指针移位操作不一定有意义。如果 ptr 所指的是整型数组中的某个元素，则 ptr 可以按照预期移动到下一个元素。如果 ptr 所指的只是一个独立的整数变量，则移动指针操作将产生未定义的结果。

（b）的含义是先检查 ival 的值是否是非 0，如果非 0 继续检查 (ival + 1) 的值是否是非 0。只有当两个值都是非 0 值时，表达式的求值结果为真；否则为假。在 4.1.3 节中我们学习到，如果二元运算符的两个运算对象涉及同一个对象并改变对象的值，则这是一种不好的程序写法，应该改写。所以，按照程序的原意，本式应该改写成 ival && (ival + 1) 。

（c）的含义是比较 vec[ival] 和 vec[ival + 1] 的大小，如果前者较小则求值结果为真，否则为假。与（b）式一样，本式也出现了二元运算符的两个运算对象涉及同一个对象并改变对象值的情况，应该改写为 vec[ival] <= vec[ival + 1] 。
### 4.20
（a）是合法的，后置递增运算符的优先级高于解引用运算符，其含义是解引用当前迭代器所处位置的对象内容，然后把迭代器的位置向后移动一位。

（b）是非法的，解引用 iter 得到 vector 对象当前的元素，结果是一个 string，显然 string 没有后置递增操作。

（c）是非法的，解引用运算符的优先级低于点运算符，所以该式先计算 iter.empty() ，而迭代器并没有定义 empty 函数，所以无法通过编译。

（d）是合法的，iter->empty(); 等价于 (*iter).empty(); 。解引用迭代器得到迭代器当前所指的元素，结果是一个 string，显然字符串可以判断是否为空，empty 函数在此有效。

（e）是非法的，前置递增运算符的优先级和解引用运算符的优先级相同，但表达式的结合性是自右向左（右结合律）。该式先解引用 iter，得到迭代器当前所指的元素，结果是一个 string，显然 string 没有前置递增操作。

（f）是合法的，后置递增运算符的优先级和成员访问运算符的优先级相同，但表达式的结合性是从左往右（左结合律）。iter++->empty(); 等价于 (*iter++).empty(); 。含义是解引用迭代器当前位置的对象内容，得到一个字符串，判断该字符串是否为空，然后把迭代器向后移动一位。
### 4.23
题目中的几个运算符的优先级次序从高到低是加法运算、相等运算符、条件运算符和赋值运算符，因此式子的求值过程是先把 s 和 s[s.size() - 1] 相加得到一个新字符串，然后该字符串与字符 s 比较是否相等，这是一个非法操作，并且与程序的原意不符。

要想实现程序的原意，即先判断字符串 s 的最后一个字符是否是 s ，如果是，什么也不做；如果不是，在 s 的末尾添加一个字符 s ，我们应该添加括号强制限定运算符的执行顺序。
```c++
string p1 = s + (s[s.size() - 1] == 's' ? "" : "s");
```
### 4.24
先考查 grade > 90 是否成立，如果成立，第一个条件表达式的值为 “high pass”；如果不成立，第一个条件表达式的值为 grade < 60。这条语句是无法编译通过的，因为条件运算符要求两个结果表达式的类型相同或者可以相互转化。即使假设语法上通过了，也就是说，第一个条件表达式的求值结果分为 3 种，分别是 “high pass”、1 和 0。接下来根据第一个条件表达式的求值结果解第二个条件表达式，求值结果是 “fail” 或 “pass”。上述求值过程显然与我们的期望是不符的。
### 4.25
在位运算符中，运算符 ~ 高于 << ，因此先对 q 按位求反，因为位运算符的运算对象应该是整数类型，所以字符 q 首先转换为整数类型。如题所示，char 占 8 位而 int 占 32 位，所以字符 q 转换后得到 00000000 00000000 00000000 01110001 ，按位求反得到 11111111 11111111 11111111 10001110 ；接着执行移位操作，得到 11111111 11111111 11100011 10000000 。

C++规定整数按照其补码形式存储，对上式求补，得到 10000000 00000000 00011100 10000000 ，即最终结果的二进制形式，转换成十进制形式是 -7296。
### 4.26
如果使用 unsigned int 作为 quiz1 的类型，则由于 C++ 规定 unsigned int 所占空间的最小值是 16，所以在很多机器环境中，该数据类型不足以存放全部学生的信息，从而造成了信息丢失，无法完成题目要求的任务。
### 4.27
（a）按位与，结果是：00000000 00000000 00000000 00000011 ，即 3。

（b）按位或，结果是：00000000 00000000 00000000 00000111 ，即 7。

（c）逻辑与，所有非 0 整数对应的布尔值都是 true，所以该式等价于 true && true，结果是 true。

（d）逻辑或，所有非 0 整数对应的布尔值都是 true，所以该式等价于 true || true，结果是 true。
### 4.28
sizeof(x) 的运算对象 x 是数组的名字，求值结果是整个数组所占空间的大小，等价于对数组中所有的元素各执行一次 sizeof 运算并对所得结果求和。尤其需要注意，sizeof 运算符不会把数组转换成指针来处理。在本例中，x 是一个 int 数组且包含 10 个元素，所以 sizeof(x) 的求值结果是 10 个 int 值所占的内存空间总和。
sizeof(*x) 的运算对象 *x 是一条解引用表达式，此处的 x 既是数组的名称，也表示指向数组首元素的指针，解引用该指针得到指针所指的内容，在本例中是一个 int。所以，sizeof(*x) 在这里等价于 sizeof(int)，即 int 所占的内存空间。
sizeof(x) / sizeof(*x) 可以理解为数组 x 所占的全部空间除以其中一个元素所占的空间，得到的结果应该是数组 x 的元素总数。实际上，因为 C++ 的内置数组并没有定义成员函数 size()，所以通常无法直接得到数组的容量。本题所示的方法是计算得到数组容量的一种常规方法。
sizeof(p) 的运算对象 p 是一个指针，求值结果是指针所占的空间大小。64位指针为8字节，32位为4字节
sizeof(*p) 的运算对象 *p 是指针 p 所指的对象，即 int 变量 x，所以求值结果是 int 值所占的空间大小。
### 4.30
（a）的含义是先求变量 x 所占空间的大小，然后与变量 y 的值相加；因为 sizeof 运算符的优先级高于加法运算符的优先级，所以如果想求表达式 x+y 所占的内存空间，应该改为 sizeof(x + y)。

（b）的含义是先定位到指针 p 所指的对象，然后求该对象中名为 mem 的数组成员第 i 个元素的尺寸。因为成员选择运算符的优先级高于 sizeof 的优先级，所以本例无须添加括号。

（c）的含义是先求变量 a 在内存中所占空间的大小，再把求得的值与变量 b 的值比较。因为 sizeof 运算符的优先级高于关系运算符的优先级，所以如果想求表达式 a < b 所占的内存空间，应该改为 sizeof(a < b)。

（d）的含义是求函数 f() 返回值所占内存空间的大小，因为函数调用运算符的优先级高于 sizeof 的优先级，所以本例无须添加括号。
### 4.31
本题从程序运行结果来说，使用前置版本或后置版本是一样的，这是因为递增递减运算符与真正使用这两个变量的语句位于不同的表达式中，所以不会有什么影响。
### 4.32
首先定义了一个常量表达式 size，它的值是 5；接着以 size 作为维度创建一个整型数组 ia，5 个元素分别是 1～5。

for 语句头包括三部分：第一部分定义整型指针指向数组 ia 的首元素，并且定义了一个整数 ix，赋给它初始值 0；第二部分判断循环终止的条件，当 ix 没有达到 size 同时指针 ptr 没有指向数组最后一个元素的下一位置时，执行循环体；第三部分令变量 ix 和指针 ptr 分别执行递增操作。
### 4.33
C++ 规定条件运算符的优先级高于逗号运算符，所以 someValue ? ++x, ++y : --x, --y; 实际上等价于 (someValue ? ++x, ++y : --x), --y; 。它的求值过程是，首先判断 someValue 是否为真，如果为真，依次执行 ++x 和 ++y，最后执行 --y ；如果为假，执行 --x 和 --y。
### 4.34
（a）if 语句的条件应该是布尔值，因此 float 型变量 fval 自动转换成布尔值，转换规则是所有非 0 值转换为 true，0 转换为 false。

（b）ival 转换成 float，与 fval 求和后所得的结果进一步转换为 double 类型。

（c）cval 执行整型提升转换为 int，与 ival 相乘后所得的结果转换为 double 类型，最后再与 dval 相加。
### 4.35
（a）字符 a 提升为 int，与 3 相加所得的结果再转换为 char 并赋给 cval。

（b）ival 转换为 double，与 1.0 相乘的结果也是 double 类型，ui 转换为 double 类型后与乘法得到的结果相减，最终的结果转换为 float 并赋给 fval。

（c）ui 转换为 float，与 fval 相乘的结果转换为 double 类型并赋给 dval。

（d）ival 转换为 float，与 fval 相加所得的结果转换为 double 类型，再与 dval 相加后结果转换为 char 类型。
### 4.36
```c++
i *= static_cast<int>(d);
```
### 4.37
（a）pv = static_cast<void*>(const_cast<string*>(ps));

（b）i = static_cast<int>(*pc);

（c）pv = static_cast<void*>(&d);

（d）pc = static_cast<char*>(pv);
### 4.38
把 j / i 的值强制类型转换成 double，然后赋值给 slope。请注意，如果 i 和 j 的类型都是 int，则 j / i 的求值结果仍然是 int，即使除不尽也只保留商的整数部分（向零取整），最后再转换成 double 类型。