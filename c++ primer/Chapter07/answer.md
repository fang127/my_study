### 7.5
应该是const，const可以接受常量对象和非常量对象，可以提高函数灵活性，其次，返回对象的姓名和地址，const避免使用中修改。
### 7.8
因为read函数要通过读取单价和销量计算出总销售额，从而赋值给类对象中的数据成员总销售额，需要改变数据成员，所以是非const，而print函数只负责打印信息，不改变数据成员，因此是const
### 7.10
因为 read 函数的返回类型是引用（左值），所以 read(cin, data1) 的返回值可以继续作为外层 read 函数的实参使用。该条件检验读入 data1 和 data2 的过程是否正确，如果正确，条件满足；否则条件不满足。
### 7.16
在类的定义中，可以包含 0 个或者多个访问说明符，并且对于某个访问说明符能出现多少次以及能出现在哪里都没有严格规定。每个访问说明符指定接下来的成员的访问级别，有效范围直到出现下一个访问说明符或者到达类的结尾为止。

一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在 public 说明符之后，而数据成员和作为实现部分的函数则应该跟在 private 说明符之后。
### 7.17
类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果使用 struct 关键字，则定义在第一个说明符之前的成员是 public 的；相反，如果使用 class 关键字，则这些成员是 private 的。
### 7.18
封装是指保护类的成员不被随意访问的能力。通过把类的实现细节设置为 private，我们就能完成类的封装。封装实现了类的接口和实现的分离。

如书中所述，封装有两个重要的优点：

1. 确保用户代码不会无意间破坏封装对象的状态；  
2. 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。  
3. 一旦把数据成员定义成 private 的，类的作者就可以比较自由地修改数据了。当实现部分发生改变时，只需要检查类的代码本身以确认这次改变有什么影响；换句话说，只要类的接口不变，用户代码就无须改变。如果数据是 public 的，则所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码，之后才能重新使用该程序。

把数据成员的访问权限设成 private 还有另外一个好处，这么做能防止由于用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，将错误的搜索限制在有限范围内将能极大地简化更改问题及修正程序等工作。
### 7.19
根据上述分析，我们把数据成员 name 和 address 设置为 private，这样可以避免用户程序不经意间修改和破坏它们；同时把构造函数和两个获取数据成员的接口函数设置为 public，以便于我们在类的外部访问。
### 7.20
友元为类的非成员接口函数提供了访问类私有成员的能力，这种能力的提升利弊共存。
### 7.25
Screen 的 4 个数据成员都是内置类型（string 类定义了拷贝和赋值运算符），因此直接使用类对象执行拷贝和赋值操作是可以的。
### 7.28
返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。如果我们把一系列这样的操作连接在一起的话，所有这些操作将在同一个对象上执行。

在上一个练习中，mov、set 和 display 函数的返回类型都是 Screen & ，表示我们首先移动光标至 (4, 0) 位置，然后将该位置的字符修改为 # ，最后输出 myScreen 的内容。

相反，如果我们把 mov、set 和 display 函数的返回类型改成 Screen，则上述函数各自只返回一个临时副本，不会改变 myScreen 的值。
### 7.30
通过 this 指针访问成员的优点是，可以非常明确地指出访问的是对象的成员，并且可以在成员函数中使用与数据成员同名的形参；缺点是显得多余，代码不够简洁。
### 7.33
如果添加如题目所示的 size 函数将会出现编译错误。因为该函数的返回类型 pos 本身定义在 Screen 类的内部，所以在类的外部无法直接使用 pos。要想使用 pos，需要在它的前面加上作用域 Screen:: 。
### 7.34
这样会导致编译错误，因为对 pos 的使用出现在它的声明之前，此时编译器并不知道 pos 到底是什么含义。
### 7.35
```c++
typedef string Type;            // 声明类型别名 Type 表示 string
Type initVal();                 // 声明函数 initVal，返回类型是 Type
class Exercise {                // 定义一个新类 Exercise
public:
    typedef double Type;        // 在内层作用域重新声明类型别名 Type 表示 double
    Type setVal(Type);          // 声明函数 setVal，参数和返回值的类型都是 Type
    Type initVal();             // 在内层作用域重新声明函数 initVal，返回类型是 Type

private:
    int val;                    // 声明私有数据成员 val
};
// 定义函数 setVal，此时的 Type 显然是外层作用域的,加上Exercise::后才正确，是类内的Type
Exercise::Type Exercise::setVal(Type parm) 
{
    val = parm + initVal();     // 此处使用的是类内的 initVal 函数
    return val;
}
```
### 7.36
在类 X 中，两个数据成员声明的顺序是 rem 在前，base 在后，所以当执行 X 对象的初始化操作时先初始化 rem。如上述代码所示，初始化 rem 要用到 base 的值，而此时 base 尚未被初始化，因此会出现错误。该过程与构造函数初始值列表中谁出现在前面谁出现在后面没有任何关系。
```c++
struct X 
{
    X(int i, int j) : base(i), rem(base % j) {}
    int base, rem;
};
```
### 7.37
Sales_data first_item(cin); 使用了接受 std::istream & 参数的构造函数，该对象的成员值依赖于用户的输入。

Sales_data next; 使用了 Sales_data 的默认构造函数，其中 string 类型的成员 bookNo 默认初始化为空字符串，其他几个成员使用类内初始值初始化为 0.

Sales_data last("9-999-99999-9"); 使用了接受 const string & 参数的构造函数，其中 bookNo 使用实参初始化为 “9-999-99999-9”，其他几个成员使用类内初始值初始化为 0.
### 7.38
```c++
Sales_data(std::istream &is = std::cin) {read(is,*this);}
```
### 7.39
如果我们为构造函数的全部形参都提供了默认实参（包括为只接受一个形参的构造函数提供默认实参），则该构造函数同时具备了默认构造函数的作用。此时即使我们不提供任何实参地创建类的对象，也可以找到可用的构造函数。

然而，如果按照本题的叙述，我们为两个构造函数同样都赋予了默认实参，则这两个构造函数都具有了默认构造函数的作用。一旦我们不提供任何实参地创建类的对象，则编译器无法判断这两个（重载的）构造函数哪个更好，从而出现了二义性错误。
### 7.44
上述语句的含义是创建一个 vector 对象 vec，该对象包含 10 个元素，每个元素的类型都是 NoDefault 且执行默认初始化。然而，因为我们在类 NoDefault 的定义中没有设计默认构造函数，所以所需的默认初始化过程无法执行。编译器会报告这一错误。
### 7.45
与上一个练习相比，如果把 vector 的元素类型更改为 C，则该声明是合法的，这是因为我们给类型 C 定义了带参数的默认构造函数，它可以完成声明语句所需的默认初始化操作。
### 7.46
（a）是错误的，类可以不提供任何构造函数，这时编译器自动实现一个合成的默认构造函数。

（b）是错误的，如果某个构造函数包含若干形参，但是同时为这些形参都提供了默认实参，则该构造函数也具备默认构造函数的功能。

（c）是错误的，因为如果一个类没有默认构造函数，也就是说我们定义了该类的某些构造函数但是没有为其设计默认构造函数，则当编译器确实需要隐式地使用默认构造函数时，该类无法使用。所以一般情况下，都应该为类构建一个默认构造函数。

（d）是错误的，对于编译器合成的默认构造函数来说，类类型的成员执行各自所属类的默认构造函数，内置类型和复合类型的成员只对定义在全局作用域中的对象执行初始化。
### 7.47
接受一个 string 参数的 Sales_data 构造函数应该是 explicit 的，否则，编译器就有可能自动把一个 string 对象转换成 Sales_data 对象，这种做法显得有些随意，某些时候会与程序员的初衷相违背。

使用 explicit 的优点是避免因隐式类类型转换而带来意想不到的错误，缺点是当用户的确需要这样的类类型转换时，不得不使用略显繁琐的方式来实现。
### 7.48
在本题给出的代码中，第一行创建了一个 string 对象，第二行和第三行都是调用 Sales_data 的构造函数（该构造函数接受一个 string）创建它的对象。此处无须任何类类型转换，所以不论 Sales_data 的构造函数是不是 explicit 的，item1 和 item2 都能被正确地创建，它们的 bookNo 成员都是 9-999-99999-9，其他成员都是 0.
### 7.49
（a）是正确的，编译器首先用给定的 string 对象 s 自动创建一个 Sales_data 对象，然后这个新生成的临时对象传给 combine 的形参（类型是 Sales_data），函数正确执行并返回结果。

（b）无法编译通过，因为 combine 函数的参数是一个非常量引用，而 s 是一个 string 对象，编译器用 s 自动创建一个 Sales_data 临时对象，但是这个新生成的临时对象无法传递给 combine 所需的非常量引用。如果我们把函数声明修改为 Sales_data &combine(const Sales_data &); 就可以了。

（c）无法编译通过，因为我们把 combine 声明成了常量成员函数，所以该函数无法修改数据成员的值。
### 7.50
是的，Person(std::istream &is) { read(is, *this); };应该是explicit，避免因隐式类类型转换而带来意想不到的错误。
### 7.51
string 接受的单参数是 const char * 类型，如果我们得到了一个常量字符指针（字符数组），则把它看作 string 对象是自然而然的过程，编译器自动把参数类型转换成类类型也非常符合逻辑，因此我们无须指定为 explicit 的。

与 string 相反，vector 接受的单参数是 int 类型，这个参数的原意是指定 vector 的容量。如果我们在本来需要 vector 的地方提供一个 int 值并且希望这个 int 值自动转换成 vector，则这个过程显得比较牵强，因此把 vector 的单参数构造函数定义成 explicit 的更加合理。
### 7.52
程序的意图是对 item 执行聚合类初始化操作，用花括号内的值初始化 item 的数据成员。然而实际过程与程序的原意不符合，编译器会报错。

这是因为聚合类必须满足一些非常苛刻的条件，其中一项就是没有类内初始值，而在 2.6.1 节给出的定义中，数据成员 units_sold 和 revenue 都包含类内初始值。

只要去掉这两个类内初始值，程序就可以正常运行了。
### 7.54
这些以 set_ 开头的成员不能声明成 constexpr，这些函数的作用是设置数据成员的值，而 constexpr 函数只能包含 return 语句，不允许执行其他任务。
### 7.55
因为 Data 类是聚合类，所以它也是一个字面值常量类。
### 7.56
静态成员是指声明语句之前带有关键字 static 的类成员，静态成员不是任意单独对象的组成部分，而是由该类的全体对象所共享。

静态成员的优点包括：作用域位于类的范围之内，避免与其他类的成员或者全局作用域的名字冲突；可以是私有成员；通过阅读程序可以非常容易地看出静态成员与特定类关联，使得程序的含义清晰明了。

静态成员与普通成员的区别主要体现在：普通成员与类的对象关联，是某个具体对象的组成部分；而静态成员不从属于任何具体的对象，它由该类的所有对象共享。另外，还有一个细微的区别，静态成员可以作为默认实参，而普通数据成员不能作为默认实参。
### 7.58
在类的内部，rate 和 vec 的初始化是错误的，因为除了静态常量成员之外，其他静态成员不能在类的内部初始化。另外，example.C 文件的两条语句也是错误的，因为在这里我们必须给出静态成员的初始值（类外初始化静态成员）。