### 12.1
b2被销毁，b1有四个对象
### 12.3
需要，如果strblob对象为常量对象，则只能调用const的成员函数，所以需要const版本的front和back
### 12.4
当i > 0时，说明不为空，可以调用back以及front以及pop_back函数。
### 12.5
未编写接受一个初始化列表参数的显式构造函数，意味着可以进行列表向 StrBlob 的隐式类型转换，亦即在需要 StrBlob 的地方（如函数的参数），可以使用列表进行代替。而且，可以进行拷贝形式的初始化（如赋值）。这令程序编写更为简单方便。

但这种隐式转换并不总是好的。例如，列表中可能并非都是合法的值。再如，对于接受 StrBlob 的函数，传递给它一个列表，会创建一个临时的 StrBlob 对象，用列表对其初始化，然后将其传递给函数，当函数完成后，此对象将被丢弃，再也无法访问了。对于这些情况，我们可以定义显式的构造函数，禁止隐式类类型转换。
### 12.8
p 将转换为布尔值，这意味着分配的动态内存没有机会被释放。结果，将发生内存泄漏。
### 12.9
1. 内存泄漏发生。因为在执行 r = q 之后，没有指向 int r 指向的指针。这意味着没有机会为它释放内存。
2. 这是安全的。因为在'r2 = q2'之后，属于 r2 的引用计数减少到 0，属于 q2 的引用计数增加到 2，那么 r2 分配的内存会自动释放。
### 12.10
正确
### 12.11
std::shared_ptr<int>(p.get()) 构造了一个临时的 shared_ptr 并将其复制到参数中。然而，这并不是 p 的副本。因此，在这个主函数结束时，p 将会释放已经在 process() 函数内部释放过的内存。这就是产生 "double freed or corruption" 错误的原因。
### 12.12
(a) true
(b) false shared_ptr接受一个指针的构造函数说explicit的，不可值传递一个内置指针类型
(c) false 同上
(d) true 但是执行完process后，p会成为空悬指针。
### 12.13
sp会成为空悬指针，在程序结束自行释放，会造成double释放，产生未定义的错误。
### 12.16
(a) 错误，无法int转为int *
(b) 以下代码可以编译，但在运行时会导致错误。原因是当unique_ptr p1超出作用域时，会调用delete来释放对象。但该对象并非通过new分配，因此操作系统会抛出错误。
(c) 这段代码可以编译，但在运行时会导致悬垂指针。原因是unique_ptr会释放原始指针所指向的对象。
(d) 当unique_ptr超出作用域时，它会调用delete来释放一个不是通过new分配的对象
(e) 正确
(f) 错误：运行时出现双重释放或内存损坏，两个unique_ptr指向了同一个对象。因此，当两者都超出作用域时，操作系统会抛出双重释放或内存损坏的错误。
### 12.21
原版更好，因为它更易读。
### 12.25
```c++
delete [] p;
```
### 12.29
```c++
do
{
    std::cout << "Enter word to look for, or q to quit: ";
    if (!(std::cin >> word) || word == "q")
        break;
    QueryResult result = tq.query(word);
    result.print(std::cout);
}
while(1)
```
### 12.31
对这个问题而言，vector 更好。因为，虽然 vector 不会维护元素值的序，set 会维护关键字的序，但注意到，我们是逐行读取输入文本的，因此每个单词出现的行号是自然按升序加入到容器中的，不必特意用关联容器来保证行号的升序。而从性能角度，set 是基于红黑树实现的，插入操作时间复杂性为 𝑂(𝑙𝑜𝑔𝑛)O(logn)（n 为容器中元素数目），而 vector 的 push_back 可达到常量时间。

另外，一个单词在同一行中可能出现多次。set 自然可保证关键字不重复，但对 vector 这也不成为障碍 —— 每次添加行号前与最后一个行号比较一下即可。总体性能仍然是 vector 更优。