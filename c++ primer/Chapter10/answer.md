### 10.4
accumulate 的第三个参数是和的初值，它还决定了函数的返回类型，以及函数中使用哪个加法运算符。

因此，本题中的调用是错误的，第三个参数 0 告知 accumulate，和是整型的，使用整型加法运算符。下面我们尝试输入带小数的值，函数返回的是一个整数。

正确的调用方法是将 0.0 作为第三个参数传递给 accumulate。
### 10.5
equal 使用 == 运算符比较两个序列中的元素。string 类重载了 ==，可比较两个字符串是否长度相等且其中元素对应位相同。而 C 风格字符串本质是 char * 类型，用 == 比较两个 char * 对象，只是检查两个**指针值地址**是否相等，即地址是否相等，而不会比较其中字符是否相同。所以，只有当两个序列中的指针都指向相同的地址时，equal 才会返回 true。否则，即使字符串内容完全相同，也会返回 false。
### 10.7
（a）是错误的。因为泛型算法的一个基本特点是：算法总是通过迭代器操作容器，因此不能直接向/从容器添加、删除元素（但可以读、写），无法改变容器大小。因此，对于 copy 算法，要求目标序列至少要包含与源序列一样多的元素。而此程序中，vec 进行缺省初始化，它是空的，copy 无法进行。如需改变容器大小，需要使用一类特殊的称为插入器的迭代器。我们可以将第三个参数改为 back_inserter(vec) ，通过它，copy 算法即可将 lst 中元素的拷贝插入到 vec 的末尾。
```c++
copy(lst.begin(), lst.end(), back_inserter(vec));
```
（b）这段程序仍然是错误的。粗看起来，reserve 为 vec 分配了至少能容纳 10 个 int 的内存空间，调用 fill_n 时，vec 已有足够空间。但泛型算法对于容器的要求并不是有足够的空间。而是足够的元素。此时 vec 仍然为空，没有任何元素。而算法又不具备向容器添加元素的能力，因此 fill_n 仍然失败。这里，我们还是需要使用 back_inserter 来让 fill_n 有能力向 vec 添加元素。
```c++
copy(back_inserter(vec), 10, 0);
```
### 10.8
严格来说，标准库算法根本不知道有 “容器” 这个东西。它们只接受迭代器参数，运行于这些迭代器之上，通过这些迭代器来访问元素。

因此，当你传递给算法普通迭代器时，这些迭代器只能顺序或随机访问容器中的元素，造成的效果就是算法只能读取元素、改变元素的值、移动元素，但无法添加或删除元素。

但当我们传递给算法插入器，例如 back_inserter 时，由于这类迭代器能调用下层容器的操作来向容器插入元素，造成的算法执行的效果就是向容器中添加了元素。

因此，关键要理解：标准库算法从来不直接操作容器，它们只操作迭代器，从而间接访问容器。能不能插入和删除元素，不在于算法，而在于传递给它们的迭代器是否具有这样的能力。
### 10.10
泛型算法的一大优点是 “泛型”，也就是一个算法可用于多种不同的数据类型，算法与所操作的数据结构分离。这对编程效率的提升是非常巨大的。

要做到算法与数据结构分离，重要的技术手段就是使用迭代器作为两者的桥梁。算法从不操作具体的容器，从而也就不存在与特定容器绑定，不适用于其他容器的问题。算法只操作迭代器，由迭代器真正实现对容器的访问。不同容器实现自己特定的迭代器（但不同迭代器是相容的），算法操作不同迭代器就实现了对不同容器的访问。

因此，并不是算法应该改变或不改变容器的问题。为了实现与数据结构的分离，为了实现通用性，算法根本就不知道容器的存在。算法访问数据的唯一通道是迭代器。是否改变容器大小，完全是迭代器的选择和责任。当我们向 fill_n 传递 back_inserter 时，虽然最终效果是向容器添加了新元素，但对 fill_n 来说，根本不知道这回事儿。它仍然像往常一样（通过迭代器）向元素赋予新值，只不过这次是通过 back_inserter 来赋值，而 back_inserter 选择将新值添加到了容器而已。\
### 10.23
bind 是可变参数的。它接受的第一个参数是一个可调用对象，即实际工作函数 A，返回供算法使用的新的可调用对象 B。若 A 接受 x 个参数，则 bind 的参数个数应该是 x+1，即除了 A 外，其他参数应一一对应 A 所接受的参数。这些参数中有一部分来自于 B(_n) ，另外一些来自于所处函数的局部变量。
### 10.26
插入迭代器又称插入器，本质上是一种迭代器适配器。如前所述，标准库算法为了保证通用性，并不直接操作容器，而是通过迭代器来访问容器元素。因此，算法不具备直接向容器插入元素的能力。而插入器正是帮助算法实现向容器插入元素的机制。

除了 back_inserter，标准库还提供了另外两种插入器：front_inserter 和 inserter。三者的差异在于如何向容器插入元素：back_inserter 调用 push_back；front_inserter 调用 push_front；inserter 则调用 insert。显然，这也决定了它们插入元素位置的不同。back_inserter 总是插入到容器尾元素之后；front_inserter 总是插入到容器首元素之前；而 inserter 则是插入到给定位置（作为 inserter 的第二个参数传递给它）之前。因此，需要注意这些特点带来的元素插入效果的差异。例如，使用 front_inserter 向容器插入一些元素，元素最终在容器中的顺序与插入顺序相反，但 back_inserter 和 inserter 则不会有这个问题。 
### 10.38
1. 输入迭代器：只读，不写；单遍扫描，只能递增；还支持相等性判定运算（==、!=）、解引用运算符（*）（只出现在赋值运算符右侧）和箭头运算符（->）。
2. 输出迭代器：只写，不读；单遍扫描，只能递增；支持解引用运算符（*）（只出现在赋值运算符左侧）。
3. 前向迭代器：可读、写；多遍扫描；只能递增；支持所有输入、输出迭代器的操作。
4. 双向迭代器：可读、写；多遍扫描；可递增、递减；支持所有向前迭代器操作。
5. 随机访问迭代器：可读、写；多遍扫描；支持全部迭代器运算，除了上述迭代器类别支持的操作外，还有：
比较两个迭代器相对位置的关系运算符（<、<=、> 和 >=）
迭代器和一个整数值的加减运算（+、+=、- 和 -=）令迭代器在序列中前进或后退给定整数个元素
两个迭代器上的减法运算符（-）得到其距离
下标运算符
### 10.39
list的迭代器属于双向迭代器
vector迭代器属于随机访问迭代器
### 10.40
copy 要求前两个参数至少是输入迭代器，表示一个输入范围。它读取这个范围中的元素，写入到第三个参数表示的输出序列中，因此第三个参数至少是输出迭代器。
reverse 要反向处理序列，因此它要求两个参数至少是双向迭代器。
unique 顺序扫描元素，覆盖重复元素，因此要求两个参数至少是前向迭代器。“至少” 意味着能力更强的迭代器是可接受的。
### 10.41
1. 将范围 [beg, end) 值等于 old_val 的元素替换为 new_val。
2. 将范围 [beg, end) 满足谓词 pred 的元素替换为 new_val。
3. 将范围 [beg, end) 的元素拷贝到目的序列 dest 中，将其中值等于 old_val 的元素替换为 new_val。
4. 将范围 [beg, end) 的元素拷贝到目的序列 dest 中，将其中满足谓词 pred 的元素替换为 new_val。